<!DOCTYPE html>
<html lang="id">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
		<meta name="referrer" content="no-referrer" />

		<!-- NOTE: isi og:url + canonical dengan URL final halaman kamu -->
		<meta property="og:url" content="" />
		<link rel="canonical" href="" />

		<meta property="og:title" content="MADETOTO2 - Spin & Win" />
		<meta name="description" content="PUTAR RODANYA & DAPATKAN HADIAH FANTASTIS HINGGA 200 RIBU RUPIAH!" />
		<meta property="og:type" content="website" />
		<meta property="og:image" content="https://shortq.org/gmbrmadetoto2" />
		<meta property="og:image:width" content="1200" />
		<meta property="og:image:height" content="630" />
		<meta name="twitter:card" content="summary_large_image" />
		<meta name="twitter:title" content="MADETOTO2 - Spin & Win" />
		<meta name="twitter:description" content="PUTAR RODANYA &amp; DAPATKAN HADIAH FANTASTIS HINGGA 200 RIBU RUPIAH!" />
		<meta name="twitter:image" content="https://shortq.org/gmbrmadetoto2" />

		<meta name="theme-color" content="#071a12" />
		<link rel="shortcut icon" href="https://shortq.org/gmbrmadetoto2" type="image/x-icon" />

		<style>
			    /* =========================
					   * BASE / TOKENS (PREMIUM — GREEN DEPTH SOFT)
					   * ======================= */
			    *,
			    *::before,
			    *::after {
			        box-sizing: border-box;
			    }

			    * {
			        margin: 0;
			        padding: 0;
			    }

			    :root {
			        color-scheme: dark;

			        /* ✅ softer green depth (less “harsh”, more premium) */
			        --bg0: #04110d;
			        --bg1: #061c14;
			        --bg2: #05271c;

			        /* gold metal (keep as rim accent, but more balanced) */
			        --gold0: #fff1d3;
			        --gold1: #f3b24a;
			        --gold2: #7a3f13;

			        /* green accents (soft modern) */
			        --green0: #d7ffe9;
			        --green1: #3be07b;
			        --green2: #128a45;

			        --text: rgba(255, 255, 255, 0.94);
			        --muted: rgba(255, 255, 255, 0.72);
			        --muted2: rgba(255, 255, 255, 0.56);

			        --card: rgba(59, 224, 123, 0.06);
			        --cardBorder: rgba(59, 224, 123, 0.2);

			        --radius-lg: 20px;
			        --radius-md: 14px;

			        /* ✅ smoother shadows (less “overglow”) */
			        --shadow-soft: 0 0 56px -16px rgba(59, 224, 123, 0.16);
			        --shadow-deep: 0 26px 86px rgba(0, 0, 0, 0.6);

			        --ring: rgba(59, 224, 123, 0.56);

			        --safe-top: env(safe-area-inset-top, 0px);
			        --safe-right: env(safe-area-inset-right, 0px);
			        --safe-bottom: env(safe-area-inset-bottom, 0px);
			        --safe-left: env(safe-area-inset-left, 0px);

			        --gpu: translateZ(0);

			        /* wheel */
			        --rim-pad: clamp(12px, 3vw, 15px);
			        --inner-safe-scale: 0.986;
			    }

			    html {
			        width: 100%;
			        height: 100%;
			        background: var(--bg0);
			        overscroll-behavior: none;
			        -webkit-text-size-adjust: 100%;
			        text-rendering: optimizeLegibility;
			        scrollbar-gutter: stable;
			    }

			    body {
			        min-height: 100svh;
			        color: var(--text);
			        font-family:
			            ui-sans-serif,
			            system-ui,
			            -apple-system,
			            BlinkMacSystemFont,
			            "SF Pro Display",
			            "SF Pro Text",
			            "Segoe UI Variable",
			            "Segoe UI",
			            Roboto,
			            Oxygen,
			            Ubuntu,
			            Cantarell,
			            "Helvetica Neue",
			            Arial,
			            sans-serif;
			        -webkit-font-smoothing: antialiased;
			        text-rendering: optimizeLegibility;
			        overscroll-behavior: none;
			        position: relative;
			        isolation: isolate;

			        background: radial-gradient(980px 560px at 82% 14%, rgba(59, 224, 123, 0.12), transparent 62%),
			            radial-gradient(920px 620px at 18% 10%, rgba(255, 255, 255, 0.045), transparent 64%),
			            radial-gradient(860px 560px at 20% 92%, rgba(20, 184, 166, 0.085), transparent 60%),
			            radial-gradient(760px 520px at 72% 84%, rgba(243, 178, 74, 0.045), transparent 66%),
			            linear-gradient(135deg, var(--bg0) 0%, var(--bg1) 48%, var(--bg2) 100%);
			    }

			    @supports (min-height: 100dvh) {
			        body {
			            min-height: 100dvh;
			        }
			    }

			    /* vignette (tight, anti-leak) */
			    body::before {
			        content: "";
			        position: fixed;
			        inset: 0;
			        pointer-events: none;
			        z-index: 0;
			        background: radial-gradient(1200px 760px at 50% 28%, rgba(255, 255, 255, 0.05), transparent 64%),
			            radial-gradient(1400px 920px at 50% 112%, rgba(0, 0, 0, 0.6), transparent 58%),
			            radial-gradient(920px 920px at -10% 22%, rgba(0, 0, 0, 0.52), transparent 56%),
			            radial-gradient(920px 920px at 110% 22%, rgba(0, 0, 0, 0.5), transparent 56%);
			        opacity: 0.92;
			        transform: var(--gpu);
			    }

			    /* subtle grain (softer) */
			    body::after {
			        content: "";
			        position: fixed;
			        inset: 0;
			        pointer-events: none;
			        z-index: 1;
			        opacity: 0.045;
			        mix-blend-mode: overlay;
			        background: repeating-linear-gradient(0deg,
			                rgba(255, 255, 255, 0.1) 0px,
			                rgba(255, 255, 255, 0.1) 1px,
			                rgba(0, 0, 0, 0) 2px,
			                rgba(0, 0, 0, 0) 4px),
			            repeating-linear-gradient(90deg,
			                rgba(255, 255, 255, 0.08) 0px,
			                rgba(255, 255, 255, 0.08) 1px,
			                rgba(0, 0, 0, 0) 2px,
			                rgba(0, 0, 0, 0) 5px);
			        transform: var(--gpu);
			    }

			    @supports (overflow: clip) {

			        html,
			        body {
			            overflow-x: clip;
			        }
			    }

			    @supports not (overflow: clip) {

			        html,
			        body {
			            overflow-x: hidden;
			        }
			    }

			    body.modal-open {
			        overflow: hidden;
			    }

			    img,
			    video,
			    canvas,
			    svg {
			        max-width: 100%;
			        height: auto;
			        display: block;
			    }

			    a,
			    button,
			    input {
			        -webkit-tap-highlight-color: transparent;
			    }

			    button {
			        touch-action: manipulation;
			    }

			    ::selection {
			        background: rgba(59, 224, 123, 0.18);
			        color: #fff;
			    }

			    /* =========================
					   * PREMIUM FX CANVAS
					   * ======================= */
			    #fxCanvas {
			        position: fixed;
			        inset: 0;
			        width: 100%;
			        height: 100%;
			        pointer-events: none;
			        z-index: 2;
			        opacity: 0.78;
			        mix-blend-mode: screen;
			        transform: var(--gpu);
			    }

			    /* =========================
					   * LAYOUT
					   * ======================= */
			    .container {
			        max-width: 1200px;
			        margin: 0 auto;
			        padding: 20px;
			        padding-left: calc(20px + var(--safe-left));
			        padding-right: calc(20px + var(--safe-right));
			        padding-top: calc(20px + var(--safe-top));
			        padding-bottom: calc(20px + var(--safe-bottom));
			        position: relative;
			        z-index: 5;
			    }

			    @media (max-width: 420px) {
			        .container {
			            padding: 16px;
			            padding-left: calc(16px + var(--safe-left));
			            padding-right: calc(16px + var(--safe-right));
			            padding-top: calc(16px + var(--safe-top));
			            padding-bottom: calc(16px + var(--safe-bottom));
			        }
			    }

			    /* =========================
					   * HEADER — CLEAN / ANTI GLOW LEAK
					   * ======================= */
			    header {
			        text-align: center;
			        padding: clamp(14px, 2.6vw, 18px) clamp(14px, 3vw, 18px);
			        position: relative;
			        z-index: 10;

			        background: radial-gradient(900px 220px at 50% -38%, rgba(255, 255, 255, 0.075), transparent 64%),
			            radial-gradient(560px 240px at 20% 34%, rgba(59, 224, 123, 0.16), transparent 64%),
			            linear-gradient(180deg, rgba(6, 28, 20, 0.86), rgba(4, 16, 12, 0.7));
			        border-radius: 16px;
			        border: 1px solid rgba(59, 224, 123, 0.2);
			        box-shadow:
			            0 16px 60px rgba(0, 0, 0, 0.54),
			            0 0 0 1px rgba(0, 0, 0, 0.24) inset,
			            0 0 40px rgba(59, 224, 123, 0.08);

			        overflow: hidden;
			        isolation: isolate;
			        transform: var(--gpu);

			        /* ✅ hard-clip to stop glow leaking */
			        -webkit-mask-image: -webkit-radial-gradient(white, black);
			        clip-path: inset(0 round 16px);

			        container-type: inline-size;
			    }

			    header::before {
			        content: "";
			        position: absolute;
			        inset: -2px;
			        pointer-events: none;
			        z-index: 0;
			        opacity: 0.3;
			        filter: blur(1px);
			        background: radial-gradient(560px 260px at 18% 28%, rgba(255, 255, 255, 0.095), transparent 66%),
			            radial-gradient(680px 280px at 86% 46%, rgba(59, 224, 123, 0.18), transparent 66%),
			            radial-gradient(560px 260px at 50% 140%, rgba(20, 184, 166, 0.085), transparent 66%);
			    }

			    header::after {
			        content: "";
			        position: absolute;
			        inset: 0;
			        pointer-events: none;
			        z-index: 1;
			        opacity: 0.5;
			        background: linear-gradient(180deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0) 46%),
			            radial-gradient(900px 240px at 50% -14%, rgba(255, 255, 255, 0.075), transparent 62%);
			        mix-blend-mode: overlay;
			    }

			    .hero-title {
			        position: relative;
			        z-index: 2;
			        font-weight: 1000;
			        text-transform: uppercase;
			        line-height: 1.05;
			        margin: 2px 0 clamp(8px, 1.4vw, 10px);
			        text-shadow: 0 16px 40px rgba(0, 0, 0, 0.6);

			        display: inline-flex;
			        flex-wrap: wrap;
			        align-items: baseline;
			        justify-content: center;
			        gap: 0.42em;

			        font-size: clamp(1.18rem, 3.2vw, 2.22rem);
			        letter-spacing: clamp(0.06em, 0.22vw, 0.1em);
			    }

			    .hero-top {
			        display: inline;
			        font-size: inherit;
			        color: rgba(215, 255, 233, 0.92);
			        white-space: nowrap;
			    }

			    .hero-brand {
			        display: inline;
			        font-size: inherit;
			        white-space: nowrap;

			        background: linear-gradient(180deg, #d7ffe9 0%, #65f0a3 44%, #3be07b 72%, #128a45 100%);
			        -webkit-background-clip: text;
			        background-clip: text;
			        color: transparent;

			        filter: drop-shadow(0 14px 28px rgba(59, 224, 123, 0.14)) drop-shadow(0 0 14px rgba(59, 224, 123, 0.1));
			    }

			    .subtitle {
			        font-size: clamp(0.74rem, 1.55cqw, 0.92rem);
			        color: rgba(215, 255, 233, 0.78);
			        font-weight: 850;
			        text-transform: uppercase;
			        letter-spacing: clamp(0.06em, 0.18cqw, 0.1em);
			        position: relative;
			        z-index: 2;
			        line-height: 1.35;
			        text-shadow: 0 10px 24px rgba(0, 0, 0, 0.56);
			        max-width: 1100px;
			        margin-left: auto;
			        margin-right: auto;
			        padding-inline: clamp(0px, 1.4cqw, 14px);
			        text-wrap: balance;
			    }

			    @supports not (font-size: 1cqw) {
			        .subtitle {
			            font-size: clamp(0.74rem, 2vw, 0.92rem);
			            padding-inline: 0;
			        }
			    }

			    /* =========================
					   * MAIN GRID
					   * ======================= */
			    .main-content {
			        display: grid;
			        grid-template-columns: 1fr 1fr;
			        gap: clamp(18px, 4vw, 34px);
			        align-items: start;
			        margin: clamp(18px, 4vw, 28px) 0 40px;
			    }

			    .main-content>* {
			        min-width: 0;
			    }

			    @media (max-width: 900px) {
			        .main-content {
			            grid-template-columns: 1fr;
			            gap: 26px;
			        }
			    }

			    /* =========================
			* WHEEL AREA — CLEAN / SMOOTH (CASINO PREMIUM)
			* ======================= */
			    .wheel-container {
			        position: relative;
			        display: flex;
			        justify-content: center;
			        align-items: flex-start;
			        isolation: isolate;
			        background: transparent;

			        --wheel-size: min(470px, 92vw, 56svh);

			        /* rim tuning */
			        --rim-pad: clamp(10px, 2.5vw, 14px);
			        --rim-edge: rgba(255, 232, 176, 0.28);
			        --rim-glow: rgba(243, 178, 74, 0.14);

			        padding-top: clamp(14px, 3vw, 20px);
			        padding-bottom: clamp(22px, 6vw, 46px);
			    }

			    @supports (height: 100dvh) {
			        .wheel-container {
			            --wheel-size: min(470px, 92vw, 56dvh);
			        }
			    }

			    /* soft beams behind wheel (lebih halus + gak bikin patchy) */
			    .wheel-container::after {
			        content: "";
			        position: absolute;
			        left: 50%;
			        top: 22%;
			        width: calc(var(--wheel-size) * 1.52);
			        height: calc(var(--wheel-size) * 1.52);
			        transform: translate(-50%, -50%);
			        border-radius: 50%;
			        pointer-events: none;
			        z-index: 0;

			        background: conic-gradient(from -12deg,
			                rgba(255, 255, 255, 0) 0deg,
			                rgba(255, 255, 255, 0.05) 14deg,
			                rgba(255, 255, 255, 0) 32deg,
			                rgba(255, 255, 255, 0.06) 54deg,
			                rgba(255, 255, 255, 0) 82deg,
			                rgba(255, 255, 255, 0.05) 108deg,
			                rgba(255, 255, 255, 0) 142deg,
			                rgba(255, 255, 255, 0.07) 176deg,
			                rgba(255, 255, 255, 0) 212deg,
			                rgba(255, 255, 255, 0.05) 244deg,
			                rgba(255, 255, 255, 0) 280deg,
			                rgba(255, 255, 255, 0.06) 312deg,
			                rgba(255, 255, 255, 0) 360deg),
			            radial-gradient(circle at 50% 50%, rgba(59, 224, 123, 0.1), transparent 66%);

			        filter: blur(1.35px);
			        opacity: 0.52;
			        animation: beamsPulse 5.2s ease-in-out infinite;
			        transform-origin: 50% 50%;
			    }

			    @keyframes beamsPulse {
			        0% {
			            opacity: 0.46;
			            transform: translate(-50%, -50%) rotate(-1deg) scale(0.994);
			        }

			        50% {
			            opacity: 0.66;
			            transform: translate(-50%, -50%) rotate(1.2deg) scale(1.01);
			        }

			        100% {
			            opacity: 0.46;
			            transform: translate(-50%, -50%) rotate(-1deg) scale(0.994);
			        }
			    }

			    .wheel-container::before {
			        content: "";
			        position: absolute;
			        width: var(--wheel-size);
			        height: var(--wheel-size);
			        left: 50%;
			        top: calc(50% - 6px);
			        transform: translate(-50%, -50%);
			        border-radius: 50%;
			        pointer-events: none;
			        z-index: 0;

			        background: radial-gradient(circle at 50% 60%, rgba(0, 0, 0, 0.72), transparent 66%),
			            radial-gradient(circle at 50% 50%, rgba(243, 178, 74, 0.06), transparent 66%),
			            radial-gradient(circle at 50% 50%, rgba(59, 224, 123, 0.07), transparent 72%);

			        filter: blur(0.35px);
			    }

			    .wheel-wrapper {
			        position: relative;
			        width: var(--wheel-size);
			        aspect-ratio: 1 / 1;
			        height: auto;
			        max-width: 100%;
			        touch-action: manipulation;
			        user-select: none;
			        -webkit-user-select: none;
			        background: transparent;
			        isolation: isolate;
			        z-index: 2;

			        transform: var(--gpu);
			        will-change: transform;
			        backface-visibility: hidden;
			        -webkit-backface-visibility: hidden;
			    }

			    /* =========================
			* POINTER (cleaner light)
			* ======================= */
			    .pointer {
			        position: absolute;
			        top: clamp(-34px, -6.4vw, -22px);
			        left: 50%;
			        transform: translateX(-50%) var(--gpu);
			        transform-origin: 50% 18%;
			        z-index: 30;
			        width: clamp(40px, 10.5vw, 58px);
			        height: clamp(56px, 13.6vw, 78px);
			        filter: drop-shadow(0 18px 30px rgba(0, 0, 0, 0.64)) drop-shadow(0 0 18px rgba(59, 224, 123, 0.1));
			        pointer-events: none;
			        backface-visibility: hidden;
			        -webkit-backface-visibility: hidden;
			    }

			    .pointer svg {
			        width: 100%;
			        height: 100%;
			        display: block;
			    }

			    .pointer.is-spin {
			        animation: pointerFloat 540ms ease-in-out infinite;
			    }

			    @keyframes pointerFloat {
			        0% {
			            transform: translateX(-50%) rotate(-1.1deg) translateY(0px);
			        }

			        50% {
			            transform: translateX(-50%) rotate(1.7deg) translateY(1px);
			        }

			        100% {
			            transform: translateX(-50%) rotate(-1.1deg) translateY(0px);
			        }
			    }

			    .pointer.is-kick {
			        animation: pointerKick 120ms ease-out 1;
			    }

			    @keyframes pointerKick {
			        0% {
			            transform: translateX(-50%) rotate(0deg);
			        }

			        45% {
			            transform: translateX(-50%) rotate(var(--kick-deg, -11deg));
			        }

			        100% {
			            transform: translateX(-50%) rotate(0deg);
			        }
			    }

			    /* =========================
			* OUTER RIM — BRUSHED METAL GOLD (CASINO 1:1 + NO PATCH)
			* Full Replace bagian .wheel-outer + pseudo nya
			* ======================= */

			    /* (optional) override rim tokens biar lebih “metal” */
			    .wheel-container {
			        /* thickness */
			        --rim-pad: clamp(10px, 2.5vw, 14px);

			        /* metal palette */
			        --rim-hi: rgba(255, 248, 232, 1);
			        --rim-mid: rgba(243, 178, 74, 1);
			        --rim-lo: rgba(122, 63, 19, 1);

			        /* edges / glow */
			        --rim-edge: rgba(255, 232, 176, 0.28);
			        --rim-edge-deep: rgba(0, 0, 0, 0.36);
			        --rim-glow: rgba(243, 178, 74, 0.14);
			        --rim-green-glow: rgba(59, 224, 123, 0.08);

			        /* brushed + sheen strength */
			        --rim-brush-a: 0.08;
			        --rim-brush-b: 0.05;
			        --rim-sheen-a: 0.26;
			        --rim-sheen-b: 0.14;
			    }

			    .wheel-outer {
			        width: 100%;
			        height: 100%;
			        border-radius: 50%;
			        padding: var(--rim-pad);
			        position: relative;
			        z-index: 2;
			        isolation: isolate;
			        overflow: hidden;
			        background-clip: padding-box;

			        /* base metal body (smooth, no harsh conic stops) */
			        background:
			            radial-gradient(circle at 28% 18%,
			                rgba(255, 255, 255, 0.36) 0%,
			                rgba(255, 255, 255, 0.12) 22%,
			                rgba(255, 255, 255, 0) 58%),
			            radial-gradient(circle at 74% 86%,
			                rgba(0, 0, 0, 0.64) 0%,
			                rgba(0, 0, 0, 0.18) 28%,
			                rgba(0, 0, 0, 0) 62%),
			            linear-gradient(180deg,
			                var(--rim-hi) 0%,
			                rgba(255, 241, 211, 0.96) 18%,
			                rgba(243, 178, 74, 0.98) 52%,
			                rgba(164, 88, 30, 1) 78%,
			                var(--rim-lo) 100%);

			        /* edge bevel */
			        box-shadow:
			            0 0 0 1px var(--rim-edge),
			            0 0 0 2px rgba(0, 0, 0, 0.18),
			            var(--shadow-deep),
			            0 0 34px var(--rim-glow),
			            0 0 22px var(--rim-green-glow);

			        transform: var(--gpu);
			        backface-visibility: hidden;
			        -webkit-backface-visibility: hidden;
			        will-change: transform;
			    }

			    .wheel-outer>* {
			        position: relative;
			        z-index: 5;
			    }

			    /* Brushed texture + moving sheen (MASKED only to the rim ring) */
			    .wheel-outer::before {
			        content: "";
			        position: absolute;
			        inset: -3px;
			        border-radius: 50%;
			        pointer-events: none;
			        z-index: 2;

			        /* IMPORTANT: effect hanya di area rim (ring), bukan ke wheel dalam */
			        -webkit-mask: radial-gradient(circle at 50% 50%,
			                transparent calc(50% - var(--rim-pad) - 1.5px),
			                #000 calc(50% - var(--rim-pad) + 0.5px),
			                #000 100%);
			        mask: radial-gradient(circle at 50% 50%,
			                transparent calc(50% - var(--rim-pad) - 1.5px),
			                #000 calc(50% - var(--rim-pad) + 0.5px),
			                #000 100%);

			        /* brushed + anisotropic reflections */
			        background:
			            /* brushed micro-lines (super halus) */
			            repeating-conic-gradient(from 0deg,
			                rgba(255, 255, 255, var(--rim-brush-a)) 0deg 0.65deg,
			                rgba(0, 0, 0, var(--rim-brush-b)) 0.65deg 1.3deg),
			            /* very soft grain direction */
			            repeating-linear-gradient(125deg,
			                rgba(255, 255, 255, 0.035) 0px,
			                rgba(255, 255, 255, 0.035) 1px,
			                rgba(0, 0, 0, 0.03) 2px,
			                rgba(0, 0, 0, 0.03) 4px),
			            /* moving sheen (specular sweep) */
			            conic-gradient(from 12deg,
			                rgba(255, 255, 255, 0) 0deg,
			                rgba(255, 255, 255, 0) 24deg,
			                rgba(255, 255, 255, var(--rim-sheen-a)) 42deg,
			                rgba(255, 255, 255, 0) 66deg,
			                rgba(255, 255, 255, 0) 170deg,
			                rgba(255, 255, 255, var(--rim-sheen-b)) 206deg,
			                rgba(255, 255, 255, 0) 236deg,
			                rgba(255, 255, 255, 0) 360deg),
			            /* tiny top highlight */
			            radial-gradient(circle at 46% 22%,
			                rgba(255, 255, 255, 0.14),
			                rgba(255, 255, 255, 0) 54%);

			        opacity: 0.38;
			        filter: blur(0.38px);
			        transform-origin: 50% 50%;
			        animation: rimSheenSpin 7.4s linear infinite;
			    }

			    /* Inner lip ring (nyatu rim -> wheel, nutup seam, tambah depth) */
			    .wheel-outer::after {
			        content: "";
			        position: absolute;
			        inset: var(--rim-pad);
			        border-radius: 50%;
			        pointer-events: none;
			        z-index: 4;

			        background:
			            radial-gradient(circle at 50% 28%,
			                rgba(255, 255, 255, 0.12),
			                rgba(255, 255, 255, 0) 56%),
			            radial-gradient(circle at 50% 78%,
			                rgba(0, 0, 0, 0.30),
			                rgba(0, 0, 0, 0) 62%);

			        box-shadow:
			            /* crisp inner edge */
			            inset 0 0 0 1px rgba(255, 232, 176, 0.18),
			            /* bevel highlight */
			            inset 0 9px 16px rgba(255, 255, 255, 0.06),
			            /* inner shadow (bikin “mengunci” wheel) */
			            inset 0 -18px 22px rgba(0, 0, 0, 0.30),
			            /* deep seam closer (anti ghost/patch di batas) */
			            inset 0 0 0 2px rgba(0, 0, 0, 0.16),
			            0 0 0 1px rgba(0, 0, 0, 0.22);

			        opacity: 0.98;
			    }

			    /* animation */
			    @keyframes rimSheenSpin {
			        to {
			            transform: rotate(360deg) translateZ(0);
			        }
			    }

			    /* reduce motion safe */
			    @media (prefers-reduced-motion: reduce) {
			        .wheel-outer::before {
			            animation: none;
			            opacity: 0.30;
			        }
			    }

			    /* =========================
			* WHEEL INNER — STABLE (SVG BACKGROUND READY)
			* ======================= */
			    .wheel-inner {
			        width: 100%;
			        height: 100%;
			        border-radius: 50%;

			        /* fallback kalau JS/SVG mati, tapi JS kamu bakal set inline background:none */
			        background: var(--wheel-bg,
			                conic-gradient(from 0deg,
			                    #064e3b 0deg 60deg,
			                    #f8fafc 60deg 120deg,
			                    #064e3b 120deg 180deg,
			                    #f8fafc 180deg 240deg,
			                    #064e3b 240deg 300deg,
			                    #f8fafc 300deg 360deg));

			        border: 1px solid rgba(255, 255, 255, 0.1);

			        /* depth tanpa bikin per-segmen beda warna */
			        box-shadow:
			            inset 0 0 0 1px rgba(0, 0, 0, 0.22),
			            inset 0 18px 30px rgba(0, 0, 0, 0.34),
			            inset 0 -14px 22px rgba(255, 255, 255, 0.05);

			        position: relative;
			        will-change: transform;
			        transform: var(--gpu);
			        overflow: hidden;
			        isolation: isolate;
			        background-clip: padding-box;
			        backface-visibility: hidden;
			        -webkit-backface-visibility: hidden;

			        --spin-dur: 6000ms;
			        --inner-safe-scale: 1;
			    }

			    /* ✅ NETRAL overlay (hapus mix-blend overlay yg bikin “beda warna aneh”) */
			    .wheel-inner::before {
			        content: "";
			        position: absolute;
			        inset: 0;
			        border-radius: 50%;
			        pointer-events: none;
			        z-index: 2;

			        background: radial-gradient(circle at 32% 24%, rgba(255, 255, 255, 0.12), transparent 60%),
			            radial-gradient(circle at 70% 76%, rgba(0, 0, 0, 0.16), transparent 64%),
			            radial-gradient(circle at 50% 58%, rgba(0, 0, 0, 0.1), transparent 70%);
			        opacity: 0.62;

			        /* penting: jangan overlay/screen di sini */
			        mix-blend-mode: normal;
			        transform: scale(var(--inner-safe-scale)) var(--gpu);
			        transform-origin: 50% 50%;
			    }

			    /* INNER EDGE RING — bikin batas rim → wheel lebih tight & premium */
			    .wheel-inner::after {
			        content: "";
			        position: absolute;
			        inset: 0;
			        border-radius: 50%;
			        pointer-events: none;
			        z-index: 3;

			        box-shadow:
			            inset 0 0 0 1px rgba(255, 255, 255, 0.1),
			            inset 0 0 0 2px rgba(255, 232, 176, 0.1),
			            inset 0 0 18px rgba(0, 0, 0, 0.26);
			        opacity: 0.95;
			    }

			    /* ✅ center-only sweep (tetap, tapi lebih “bersih”) */
			    .wheel-corefx {
			        position: absolute;
			        inset: 0;
			        border-radius: 50%;
			        pointer-events: none;
			        z-index: 6;
			        transform-origin: 50% 50%;
			        mix-blend-mode: screen;
			        opacity: 0.88;
			        filter: blur(0.75px);
			        will-change: transform;

			        background: conic-gradient(from 0deg,
			                rgba(255, 255, 255, 0) 0deg,
			                rgba(255, 255, 255, 0.14) 26deg,
			                rgba(59, 224, 123, 0.2) 58deg,
			                rgba(255, 255, 255, 0) 98deg,
			                rgba(243, 178, 74, 0.1) 140deg,
			                rgba(255, 255, 255, 0) 220deg,
			                rgba(59, 224, 123, 0.14) 294deg,
			                rgba(255, 255, 255, 0) 360deg),
			            radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.05), rgba(0, 0, 0, 0) 66%);

			        -webkit-mask: radial-gradient(circle at 50% 50%,
			                rgba(0, 0, 0, 1) 0%,
			                rgba(0, 0, 0, 1) 34%,
			                rgba(0, 0, 0, 0.86) 46%,
			                rgba(0, 0, 0, 0) 58%,
			                rgba(0, 0, 0, 0) 100%);
			        mask: radial-gradient(circle at 50% 50%,
			                rgba(0, 0, 0, 1) 0%,
			                rgba(0, 0, 0, 1) 34%,
			                rgba(0, 0, 0, 0.86) 46%,
			                rgba(0, 0, 0, 0) 58%,
			                rgba(0, 0, 0, 0) 100%);

			        animation: coreFXRotate 7s linear infinite;
			    }

			    @keyframes coreFXRotate {
			        from {
			            transform: translateZ(0) scale(var(--inner-safe-scale)) rotate(0deg);
			        }

			        to {
			            transform: translateZ(0) scale(var(--inner-safe-scale)) rotate(360deg);
			        }
			    }

			    .wheel-inner.spinning {
			        animation: spin-wheel var(--spin-dur) cubic-bezier(0.15, 0, 0.15, 1) forwards;
			    }

			    @keyframes spin-wheel {
			        from {
			            transform: rotate(var(--from-rotation, 0deg)) translateZ(0);
			        }

			        to {
			            transform: rotate(var(--rotation)) translateZ(0);
			        }
			    }

			    /* during spin: faster center sweep */
			    .wheel-inner.spinning .wheel-corefx {
			        opacity: 0.66;
			        animation-duration: 1.85s;
			    }

			    /* prize texts (DIV) — legacy (SVG text will hide these via JS style) */
			    .prize-text {
			        position: absolute;
			        left: 50%;
			        top: 50%;
			        font-weight: 1000;
			        font-size: clamp(14px, 3.2vw, 20px);
			        user-select: none;
			        pointer-events: none;
			        white-space: nowrap;
			        z-index: 10;
			        letter-spacing: 0.55px;
			        transform-origin: center center;
			        max-width: 74%;
			        overflow: hidden;
			        text-overflow: ellipsis;

			        text-shadow:
			            0 2px 0 rgba(0, 0, 0, 0.22),
			            0 10px 28px rgba(0, 0, 0, 0.58),
			            0 0 20px rgba(255, 255, 255, 0.08);
			        -webkit-font-smoothing: antialiased;
			    }

			    /* =========================
			* CENTER HUB — stable sheen (no @property)
			* ======================= */
			    .wheel-center {
			        position: absolute;
			        top: 50%;
			        left: 50%;
			        transform: translate(-50%, -50%) var(--gpu);
			        width: clamp(62px, 15vw, 78px);
			        height: clamp(62px, 15vw, 78px);
			        border-radius: 50%;
			        overflow: hidden;
			        isolation: isolate;

			        background: radial-gradient(circle at 30% 25%, rgba(255, 255, 255, 0.28), transparent 50%),
			            radial-gradient(circle at 55% 65%, rgba(0, 0, 0, 0.34), transparent 66%),
			            linear-gradient(180deg, rgba(255, 241, 211, 0.96), rgba(243, 178, 74, 0.98), rgba(122, 63, 19, 1));

			        border: 1px solid rgba(255, 232, 176, 0.28);
			        box-shadow:
			            0 22px 54px rgba(0, 0, 0, 0.62),
			            0 0 22px rgba(243, 178, 74, 0.14),
			            0 0 36px rgba(59, 224, 123, 0.1),
			            inset 0 0 0 1px rgba(0, 0, 0, 0.18);

			        z-index: 20;
			        backface-visibility: hidden;
			        -webkit-backface-visibility: hidden;
			        will-change: transform, filter;
			    }

			    .wheel-center .hub-sheen {
			        position: absolute;
			        inset: -10%;
			        border-radius: 50%;
			        pointer-events: none;
			        z-index: 0;
			        opacity: 0.7;
			        mix-blend-mode: screen;
			        filter: blur(0.25px);
			        will-change: transform;
			        background: conic-gradient(from 0deg,
			                rgba(255, 255, 255, 0) 0deg,
			                rgba(255, 255, 255, 0.18) 28deg,
			                rgba(255, 255, 255, 0) 78deg,
			                rgba(59, 224, 123, 0.14) 154deg,
			                rgba(255, 255, 255, 0) 234deg,
			                rgba(243, 178, 74, 0.2) 272deg,
			                rgba(255, 255, 255, 0) 360deg);
			        animation: hubSheen 7.8s linear infinite;
			    }

			    @keyframes hubSheen {
			        to {
			            transform: rotate(360deg) translateZ(0);
			        }
			    }

			    .wheel-center::before {
			        content: "";
			        position: absolute;
			        inset: 10%;
			        border-radius: 50%;
			        background: radial-gradient(circle at 30% 25%, rgba(255, 255, 255, 0.09), transparent 56%),
			            radial-gradient(circle at 50% 60%, rgba(0, 0, 0, 0.34), transparent 64%),
			            linear-gradient(180deg, rgba(10, 30, 22, 0.96), rgba(6, 18, 14, 0.82));
			        border: 1px solid rgba(255, 255, 255, 0.1);
			        box-shadow: inset 0 0 14px rgba(0, 0, 0, 0.5);
			        z-index: 1;
			    }

			    .wheel-center::after {
			        content: "";
			        position: absolute;
			        left: 50%;
			        top: 50%;
			        transform: translate(-50%, -50%);
			        width: clamp(26px, 8vw, 38px);
			        height: clamp(26px, 8vw, 38px);
			        border-radius: 50%;
			        background: radial-gradient(circle at 30% 25%, rgba(255, 255, 255, 0.14), transparent 56%),
			            radial-gradient(circle at 55% 58%, rgba(0, 0, 0, 0.44), transparent 66%),
			            linear-gradient(180deg, rgba(12, 12, 12, 0.96), rgba(22, 22, 22, 0.76));
			        border: 1px solid rgba(255, 255, 255, 0.1);
			        box-shadow: inset 0 0 14px rgba(0, 0, 0, 0.56);
			        z-index: 2;
			    }

			    .wheel-inner.spinning .wheel-center {
			        animation: hubPulse 1.28s ease-in-out infinite;
			    }

			    .wheel-inner.spinning .wheel-center .hub-sheen {
			        animation-duration: 1.12s;
			    }

			    @keyframes hubPulse {
			        0% {
			            filter: drop-shadow(0 0 10px rgba(59, 224, 123, 0.1));
			            transform: translate(-50%, -50%) scale(1) translateZ(0);
			        }

			        50% {
			            filter: drop-shadow(0 0 20px rgba(59, 224, 123, 0.18));
			            transform: translate(-50%, -50%) scale(1.04) translateZ(0);
			        }

			        100% {
			            filter: drop-shadow(0 0 10px rgba(59, 224, 123, 0.1));
			            transform: translate(-50%, -50%) scale(1) translateZ(0);
			        }
			    }

			    /* =========================
					   * CARD / INPUT
					   * ======================= */
			    .input-section {
			        background: radial-gradient(520px 260px at 18% 10%, rgba(255, 255, 255, 0.05), transparent 62%),
			            linear-gradient(135deg, rgba(59, 224, 123, 0.07), rgba(0, 0, 0, 0.3));
			        border: 1px solid rgba(59, 224, 123, 0.2);
			        border-radius: var(--radius-lg);
			        padding: clamp(18px, 4vw, 30px);
			        box-shadow:
			            0 18px 70px rgba(0, 0, 0, 0.48),
			            0 0 56px -18px rgba(59, 224, 123, 0.18);
			        margin-bottom: 14px;
			        overflow: hidden;
			        isolation: isolate;
			        position: relative;
			    }

			    .input-section::before {
			        content: "";
			        position: absolute;
			        inset: -2px;
			        pointer-events: none;
			        opacity: 0.52;
			        background: radial-gradient(420px 220px at 20% 15%, rgba(255, 255, 255, 0.09), transparent 66%),
			            radial-gradient(520px 260px at 90% 35%, rgba(59, 224, 123, 0.14), transparent 66%);
			        filter: blur(0.7px);
			    }

			    @supports ((backdrop-filter: blur(1px)) or (-webkit-backdrop-filter: blur(1px))) {
			        .input-section {
			            backdrop-filter: blur(16px);
			            -webkit-backdrop-filter: blur(16px);
			        }
			    }

			    .input-section h2 {
			        font-size: clamp(1.18rem, 2.4vw, 1.42rem);
			        margin-bottom: 10px;
			        text-shadow: 0 10px 26px rgba(0, 0, 0, 0.56);
			        letter-spacing: 0.2px;
			    }

			    .input-section p {
			        color: rgba(255, 255, 255, 0.74);
			        margin-bottom: 18px;
			        font-size: 0.95rem;
			        line-height: 1.45;
			    }

			    label {
			        display: block;
			        margin-bottom: 10px;
			        font-weight: 900;
			        color: rgba(255, 255, 255, 0.92);
			        letter-spacing: 0.2px;
			    }

			    input {
			        width: 100%;
			        height: 54px;
			        font-size: 18px;
			        text-align: center;
			        padding: 0 16px;
			        line-height: 54px;
			        text-indent: 0;

			        background: rgba(255, 255, 255, 0.055);
			        border: 1px solid rgba(255, 255, 255, 0.16);
			        border-radius: 12px;

			        color: rgba(255, 255, 255, 0.94);
			        caret-color: rgba(255, 255, 255, 0.92);

			        margin-bottom: 14px;
			        transition:
			            transform 0.12s ease,
			            box-shadow 0.22s ease,
			            border-color 0.22s ease,
			            background 0.22s ease;

			        outline: none;
			        appearance: none;
			        -webkit-appearance: none;

			        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
			        letter-spacing: 1.2px;

			        box-shadow:
			            inset 0 0 0 1px rgba(0, 0, 0, 0.3),
			            0 10px 30px rgba(0, 0, 0, 0.22);
			        -webkit-text-fill-color: rgba(255, 255, 255, 0.94);
			    }

			    input:hover {
			        border-color: rgba(255, 255, 255, 0.22);
			        background: rgba(255, 255, 255, 0.065);
			    }

			    input:focus {
			        border-color: rgba(59, 224, 123, 0.52);
			        background: rgba(255, 255, 255, 0.08);
			        box-shadow:
			            0 0 0 4px rgba(59, 224, 123, 0.14),
			            0 18px 46px rgba(0, 0, 0, 0.48);
			        transform: translateY(-1px);
			    }

			    input::placeholder {
			        color: rgba(255, 255, 255, 0.38);
			        letter-spacing: 1.2px;
			        line-height: 54px;
			        opacity: 1;
			    }

			    input::-webkit-input-placeholder {
			        line-height: 54px;
			        opacity: 1;
			    }

			    input:-webkit-autofill {
			        -webkit-text-fill-color: rgba(255, 255, 255, 0.94);
			        transition: background-color 99999s ease-out 0s;
			        box-shadow:
			            0 0 0px 1000px rgba(255, 255, 255, 0.055) inset,
			            0 10px 30px rgba(0, 0, 0, 0.22);
			        border: 1px solid rgba(255, 255, 255, 0.16);
			    }

			    .primary-btn {
			        width: 100%;
			        height: 64px;
			        font-size: 22px;
			        font-weight: 1000;
			        letter-spacing: 1.2px;
			        color: rgba(0, 0, 0, 0.92);
			        border: 1px solid rgba(59, 224, 123, 0.64);
			        border-radius: 12px;
			        cursor: pointer;
			        transition:
			            transform 0.12s ease,
			            box-shadow 0.22s ease,
			            background 0.22s ease,
			            opacity 0.2s ease,
			            filter 0.22s ease;
			        box-shadow:
			            0 0 42px rgba(59, 224, 123, 0.2),
			            0 18px 60px rgba(0, 0, 0, 0.32);
			        font-family: inherit;
			        position: relative;
			        overflow: hidden;
			        transform: var(--gpu);
			        appearance: none;
			        -webkit-appearance: none;

			        background: radial-gradient(240px 96px at 50% -24%,
			                rgba(255, 255, 255, 0.2),
			                rgba(255, 255, 255, 0) 62%),
			            linear-gradient(to bottom, var(--green1), var(--green2));
			    }

			    .primary-btn::before {
			        content: "";
			        position: absolute;
			        inset: -2px;
			        background: linear-gradient(90deg,
			                rgba(255, 255, 255, 0),
			                rgba(255, 255, 255, 0.34),
			                rgba(255, 255, 255, 0));
			        transform: translateX(-120%);
			        opacity: 0.74;
			        pointer-events: none;
			    }

			    .primary-btn:hover:not(:disabled) {
			        transform: translateY(-1px) var(--gpu);
			        filter: saturate(1.05) contrast(1.02);
			        box-shadow:
			            0 0 52px rgba(59, 224, 123, 0.26),
			            0 22px 70px rgba(0, 0, 0, 0.34);
			        background: radial-gradient(260px 104px at 50% -24%,
			                rgba(255, 255, 255, 0.22),
			                rgba(255, 255, 255, 0) 64%),
			            linear-gradient(to bottom, rgba(215, 255, 233, 0.92), var(--green1));
			    }

			    .primary-btn:hover:not(:disabled)::before {
			        animation: sheen 920ms ease-out;
			    }

			    @keyframes sheen {
			        from {
			            transform: translateX(-120%);
			        }

			        to {
			            transform: translateX(120%);
			        }
			    }

			    .primary-btn:active:not(:disabled) {
			        transform: translateY(0px) scale(0.99) var(--gpu);
			        box-shadow:
			            0 0 24px rgba(59, 224, 123, 0.18),
			            0 16px 54px rgba(0, 0, 0, 0.3);
			    }

			    .primary-btn:disabled {
			        opacity: 0.62;
			        cursor: not-allowed;
			    }

			    .primary-btn.fx::after {
			        content: "";
			        position: absolute;
			        left: var(--fx-x, 50%);
			        top: var(--fx-y, 50%);
			        width: 10px;
			        height: 10px;
			        border-radius: 50%;
			        transform: translate(-50%, -50%) scale(0);
			        background: radial-gradient(circle,
			                rgba(255, 255, 255, 0.66),
			                rgba(59, 224, 123, 0.14),
			                rgba(0, 0, 0, 0));
			        animation: ripple 520ms ease-out forwards;
			        pointer-events: none;
			    }

			    @keyframes ripple {
			        to {
			            transform: translate(-50%, -50%) scale(32);
			            opacity: 0;
			        }
			    }

			    .secondary-btn {
			        width: 100%;
			        height: 52px;
			        font-size: 16px;
			        font-weight: 1000;
			        border-radius: 12px;
			        border: 1px solid rgba(255, 255, 255, 0.16);
			        background: radial-gradient(240px 110px at 50% -30%,
			                rgba(255, 255, 255, 0.085),
			                rgba(255, 255, 255, 0) 62%),
			            rgba(0, 0, 0, 0.44);
			        color: rgba(255, 255, 255, 0.92);
			        cursor: pointer;
			        transition:
			            transform 0.12s ease,
			            background 0.2s ease,
			            border-color 0.2s ease,
			            box-shadow 0.22s ease;
			        position: relative;
			        overflow: hidden;
			        appearance: none;
			        -webkit-appearance: none;
			        box-shadow: 0 14px 50px rgba(0, 0, 0, 0.28);
			    }

			    .secondary-btn:hover {
			        background: radial-gradient(240px 110px at 50% -30%,
			                rgba(255, 255, 255, 0.1),
			                rgba(255, 255, 255, 0) 64%),
			            rgba(0, 0, 0, 0.56);
			        border-color: rgba(255, 255, 255, 0.24);
			    }

			    .secondary-btn:active {
			        transform: scale(0.99);
			    }

			    .jackpot-display {
			        display: flex;
			        flex-direction: column;
			        align-items: center;
			        gap: 6px;
			        padding-top: 14px;
			    }

			    .jackpot-label {
			        font-size: 0.85rem;
			        color: rgba(255, 255, 255, 0.62);
			    }

			    .jackpot-amount {
			        font-size: 1.24rem;
			        font-weight: 1000;
			        color: #65f0a3;
			        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
			        letter-spacing: 1px;
			        text-shadow: 0 12px 26px rgba(0, 0, 0, 0.48);
			    }

			    .jackpot-meta {
			        font-size: 0.82rem;
			        color: rgba(255, 255, 255, 0.56);
			        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
			        letter-spacing: 0.3px;
			        text-align: center;
			    }

			    .spun-message {
			        text-align: center;
			        padding: 13px 14px;
			        background: rgba(239, 68, 68, 0.16);
			        border: 1px solid rgba(239, 68, 68, 0.44);
			        border-radius: 10px;
			        color: rgba(248, 113, 113, 0.92);
			        margin-bottom: 14px;
			        line-height: 1.35;
			        box-shadow: 0 16px 44px rgba(0, 0, 0, 0.3);
			    }

			    /* =========================
					 * WINNERS — PREMIUM (FINAL PATCH)
					 * - Header & table selalu sejajar (NO | USER ID | HADIAH) di mobile
					 * - Lebih compact + lebih premium + scroll lebih halus
					 * ======================= */
			    .winners-section {
			        position: relative;
			        background: radial-gradient(680px 320px at 18% 0%, rgba(255, 255, 255, 0.055), transparent 62%),
			            radial-gradient(820px 420px at 92% 18%, rgba(59, 224, 123, 0.08), transparent 64%),
			            linear-gradient(180deg, rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.18));
			        border: 1px solid rgba(255, 255, 255, 0.09);
			        border-radius: 16px;
			        overflow: hidden;
			        min-width: 0;
			        box-shadow:
			            0 22px 78px rgba(0, 0, 0, 0.44),
			            0 0 0 1px rgba(0, 0, 0, 0.22) inset;
			        isolation: isolate;
			    }

			    .winners-section::before {
			        content: "";
			        position: absolute;
			        inset: -2px;
			        pointer-events: none;
			        opacity: 0.55;
			        background: radial-gradient(520px 220px at 24% 18%, rgba(255, 255, 255, 0.09), transparent 66%),
			            radial-gradient(620px 260px at 86% 30%, rgba(59, 224, 123, 0.14), transparent 70%),
			            linear-gradient(180deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0) 42%);
			        filter: blur(0.8px);
			    }

			    @supports ((backdrop-filter: blur(1px)) or (-webkit-backdrop-filter: blur(1px))) {
			        .winners-section {
			            backdrop-filter: blur(14px);
			            -webkit-backdrop-filter: blur(14px);
			        }
			    }

			    .winners-header {
			        position: relative;
			        display: flex;
			        align-items: center;
			        gap: 10px;

			        padding: 14px 16px;
			        font-weight: 1000;
			        font-size: 1.02rem;
			        letter-spacing: 0.2px;

			        background: radial-gradient(520px 180px at 22% -24%, rgba(255, 255, 255, 0.11), transparent 60%),
			            linear-gradient(to right, rgba(59, 224, 123, 0.22), rgba(59, 224, 123, 0.06));
			        border-bottom: 1px solid rgba(59, 224, 123, 0.12);

			        text-shadow: 0 10px 26px rgba(0, 0, 0, 0.56);
			        z-index: 2;
			    }

			    .winners-header::after {
			        content: "";
			        position: absolute;
			        left: 0;
			        right: 0;
			        bottom: 0;
			        height: 1px;
			        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
			        opacity: 0.65;
			        pointer-events: none;
			    }

			    .winners-table {
			        width: 100%;
			        max-height: 320px;
			        overflow-x: hidden;
			        overflow-y: auto;
			        display: block;
			        overscroll-behavior: contain;
			        scroll-behavior: smooth;
			        padding-bottom: 2px;

			        scrollbar-width: thin;
			        scrollbar-color: rgba(59, 224, 123, 0.28) rgba(0, 0, 0, 0.22);
			        -webkit-overflow-scrolling: touch;

			        /* sedikit “snap feel” tanpa bikin kaku */
			        scroll-padding-top: 56px;
			    }

			    .winners-table::-webkit-scrollbar {
			        width: 6px;
			    }

			    .winners-table::-webkit-scrollbar-track {
			        background: rgba(0, 0, 0, 0.22);
			    }

			    .winners-table::-webkit-scrollbar-thumb {
			        background: rgba(59, 224, 123, 0.26);
			        border-radius: 999px;
			    }

			    .winners-table::-webkit-scrollbar-thumb:hover {
			        background: rgba(59, 224, 123, 0.44);
			    }

			    .winners-table-header,
			    .winners-table-row {
			        display: grid;
			        grid-template-columns: 56px minmax(0, 1fr) clamp(120px, 28vw, 170px);
			        gap: 10px;
			        padding: 12px 16px;
			        align-items: center;
			        width: 100%;
			        min-width: 0;
			    }

			    .winners-table-header {
			        background: rgba(0, 0, 0, 0.72);
			        font-weight: 1000;
			        color: rgba(215, 255, 233, 0.92);
			        position: sticky;
			        top: 0;
			        z-index: 3;

			        border-bottom: 2px solid rgba(59, 224, 123, 0.18);
			        backdrop-filter: blur(12px);
			        -webkit-backdrop-filter: blur(12px);
			        isolation: isolate;

			        /* anti wrap biar HADIAH gak jatuh */
			        white-space: nowrap;
			    }

			    .winners-table-header>div {
			        white-space: nowrap;
			    }

			    .winners-table-row {
			        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
			        position: relative;
			        transition:
			            transform 260ms ease,
			            background 220ms ease,
			            box-shadow 220ms ease;
			        will-change: transform;
			        cursor: default;
			        user-select: none;
			    }

			    .winners-table-row::before {
			        content: "";
			        position: absolute;
			        inset: 0;
			        pointer-events: none;
			        opacity: 0;
			        background: radial-gradient(520px 120px at 50% 50%, rgba(255, 255, 255, 0.06), transparent 62%);
			        transition: opacity 220ms ease;
			    }

			    .winners-table-row:hover::before {
			        opacity: 1;
			    }

			    .winners-table-row:hover:not(.is-user) {
			        background: rgba(255, 255, 255, 0.022);
			    }

			    .winners-table-row.is-user {
			        cursor: pointer;
			        background: rgba(59, 224, 123, 0.085);
			        box-shadow:
			            inset 0 0 0 1px rgba(59, 224, 123, 0.18),
			            inset 0 0 18px rgba(59, 224, 123, 0.06);
			    }

			    .winners-table-row.is-user:hover {
			        background: rgba(59, 224, 123, 0.11);
			        box-shadow:
			            inset 0 0 0 1px rgba(59, 224, 123, 0.24),
			            0 12px 38px rgba(0, 0, 0, 0.26);
			    }

			    .winner-no {
			        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
			        color: rgba(255, 255, 255, 0.62);
			        text-align: center;
			        white-space: nowrap;
			        font-variant-numeric: tabular-nums;
			    }

			    .winner-id {
			        font-weight: 1000;
			        color: rgba(255, 255, 255, 0.96);
			        min-width: 0;
			        overflow: hidden;
			        text-overflow: ellipsis;
			        white-space: nowrap;
			        letter-spacing: 0.15px;
			    }

			    .winner-meta {
			        font-size: 0.85rem;
			        color: rgba(255, 255, 255, 0.56);
			        margin-top: 2px;
			        min-width: 0;
			        overflow: hidden;
			        text-overflow: ellipsis;
			        white-space: nowrap;
			    }

			    .winner-prize {
			        text-align: right;
			        font-weight: 1000;
			        color: #65f0a3;
			        min-width: 0;
			        overflow: hidden;
			        text-overflow: ellipsis;
			        white-space: nowrap;
			        font-variant-numeric: tabular-nums;
			        text-shadow: 0 10px 26px rgba(0, 0, 0, 0.4);
			    }

			    /* new row animations */
			    @keyframes rowIn {
			        from {
			            opacity: 0;
			            transform: translateY(-8px);
			        }

			        to {
			            opacity: 1;
			            transform: translateY(0);
			        }
			    }

			    @keyframes shimmer {
			        from {
			            transform: translateX(-70%);
			            opacity: 0;
			        }

			        15% {
			            opacity: 1;
			        }

			        to {
			            transform: translateX(70%);
			            opacity: 0;
			        }
			    }

			    .winners-table-row.is-new {
			        animation: rowIn 240ms ease-out;
			        background: linear-gradient(90deg, rgba(59, 224, 123, 0.14), rgba(255, 255, 255, 0.03));
			        box-shadow:
			            inset 0 0 0 1px rgba(59, 224, 123, 0.2),
			            inset 0 0 22px rgba(59, 224, 123, 0.06);
			    }

			    .winners-table-row.is-new::after {
			        content: "";
			        position: absolute;
			        inset: 0;
			        pointer-events: none;
			        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.22), transparent);
			        transform: translateX(-70%);
			        animation: shimmer 980ms ease-out forwards;
			    }

			    /* =========================
					 * MOBILE — KEEP 3 COLUMNS (fix “HADIAH turun”)
					 * ======================= */
			    @media (max-width: 420px) {
			        .winners-header {
			            padding: 10px 12px;
			            font-size: 0.95rem;
			            gap: 8px;
			        }

			        .winners-table-header,
			        .winners-table-row {
			            padding: 10px 12px;
			            gap: 8px;
			            grid-template-columns: 40px minmax(0, 1fr) clamp(88px, 26vw, 130px);
			        }

			        .winners-table-header {
			            font-size: 0.9rem;
			        }

			        .winner-no {
			            font-size: 0.85rem;
			        }

			        .winner-id {
			            font-size: 0.95rem;
			        }

			        .winner-meta {
			            font-size: 0.78rem;
			        }

			        .winner-prize {
			            text-align: right;
			            margin-top: 0;
			            font-size: 0.95rem;
			        }
			    }

			    /* extra small devices */
			    @media (max-width: 360px) {

			        .winners-table-header,
			        .winners-table-row {
			            grid-template-columns: 36px minmax(0, 1fr) clamp(84px, 28vw, 118px);
			        }

			        .winners-header {
			            font-size: 0.92rem;
			        }

			        .winners-table-header {
			            font-size: 0.88rem;
			        }
			    }

			    /* =========================
					   * MODAL
					   * ======================= */
			    .modal {
			        display: none;
			        position: fixed;
			        top: 0;
			        left: 0;
			        width: 100%;
			        height: 100%;
			        background: rgba(0, 0, 0, 0.78);
			        z-index: 1000;
			        align-items: center;
			        justify-content: center;
			        padding: calc(14px + var(--safe-top)) calc(14px + var(--safe-right)) calc(14px + var(--safe-bottom)) calc(14px + var(--safe-left));
			    }

			    .modal.show {
			        display: flex;
			    }

			    .modal-content {
			        background: radial-gradient(520px 280px at 18% 10%, rgba(255, 255, 255, 0.05), transparent 62%),
			            linear-gradient(135deg, rgba(6, 18, 14, 0.98), rgba(7, 30, 22, 0.96));
			        border: 1px solid rgba(59, 224, 123, 0.52);
			        border-radius: 20px;
			        padding: clamp(18px, 4vw, 40px);
			        text-align: center;
			        max-width: 520px;
			        width: 100%;
			        box-shadow:
			            0 0 72px rgba(59, 224, 123, 0.14),
			            0 28px 90px rgba(0, 0, 0, 0.6);
			        animation: zoomIn 0.22s ease-out;
			        max-height: min(84svh, 720px);
			        overflow: auto;
			        overscroll-behavior: contain;
			        -webkit-overflow-scrolling: touch;
			        scrollbar-width: thin;
			        scrollbar-color: rgba(59, 224, 123, 0.26) rgba(0, 0, 0, 0.22);
			    }

			    @supports (max-height: 84dvh) {
			        .modal-content {
			            max-height: min(84dvh, 720px);
			        }
			    }

			    @keyframes zoomIn {
			        from {
			            opacity: 0;
			            transform: scale(0.96);
			        }

			        to {
			            opacity: 1;
			            transform: scale(1);
			        }
			    }

			    .modal-content h1 {
			        font-size: clamp(1.8rem, 3.4vw, 2.5rem);
			        margin-bottom: 8px;
			        text-shadow: 0 14px 34px rgba(0, 0, 0, 0.56);
			    }

			    .modal-content p {
			        color: rgba(255, 255, 255, 0.84);
			        margin-bottom: 14px;
			        font-size: 1.05rem;
			        line-height: 1.45;
			    }

			    .prize-amount {
			        font-size: clamp(2rem, 6vw, 3rem);
			        font-weight: 1000;
			        color: var(--green0);
			        margin: 18px 0 10px;
			        line-height: 1.1;
			        text-shadow: 0 18px 44px rgba(0, 0, 0, 0.6);
			    }

			    .prize-meta {
			        font-size: 0.95rem;
			        color: rgba(255, 255, 255, 0.72);
			        margin-top: 4px;
			        line-height: 1.4;
			    }

			    .mono {
			        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
			        letter-spacing: 0.6px;
			        color: rgba(255, 255, 255, 0.92);
			        font-weight: 900;
			    }

			    .modal-actions {
			        display: flex;
			        flex-direction: column;
			        gap: 10px;
			        margin-top: 16px;
			        align-items: center;
			    }

			    .modal-actions .primary-btn {
			        max-width: 320px;
			        height: 58px;
			        font-size: 20px;
			    }

			    .modal-actions .secondary-btn {
			        max-width: 320px;
			        height: 52px;
			        font-size: 16px;
			    }

			    /* =========================
					   * TOAST
					   * ======================= */
			    .toast {
			        position: fixed;
			        left: 50%;
			        bottom: calc(18px + var(--safe-bottom));
			        transform: translateX(-50%);
			        z-index: 1200;
			        width: min(520px, calc(100vw - 28px));
			        background: rgba(0, 0, 0, 0.74);
			        border: 1px solid rgba(255, 255, 255, 0.12);
			        border-radius: 14px;
			        padding: 12px 14px;
			        display: none;
			        gap: 10px;
			        align-items: center;
			        box-shadow: 0 20px 70px rgba(0, 0, 0, 0.56);
			        backdrop-filter: blur(12px);
			        -webkit-backdrop-filter: blur(12px);
			        isolation: isolate;
			    }

			    .toast.show {
			        display: flex;
			        animation: toastIn 180ms ease-out;
			    }

			    @keyframes toastIn {
			        from {
			            opacity: 0;
			            transform: translateX(-50%) translateY(6px);
			        }

			        to {
			            opacity: 1;
			            transform: translateX(-50%) translateY(0);
			        }
			    }

			    .toast .dot {
			        width: 10px;
			        height: 10px;
			        border-radius: 50%;
			        background: var(--green1);
			        box-shadow: 0 0 14px rgba(59, 224, 123, 0.34);
			        flex: 0 0 auto;
			    }

			    .toast .msg {
			        color: rgba(255, 255, 255, 0.94);
			        font-weight: 900;
			        line-height: 1.3;
			        font-size: 0.98rem;
			    }

			    .toast.error .dot {
			        background: #ef4444;
			        box-shadow: 0 0 14px rgba(239, 68, 68, 0.34);
			    }

			    .toast.success .dot {
			        background: #65f0a3;
			        box-shadow: 0 0 14px rgba(59, 224, 123, 0.3);
			    }

			    /* =========================
					   * LOADING OVERLAY (CLAIM)
					   * ======================= */
			    .nav-loading {
			        position: fixed;
			        inset: 0;
			        display: flex;
			        align-items: center;
			        justify-content: center;
			        z-index: 2000;

			        background: rgba(0, 0, 0, 0.78);
			        backdrop-filter: blur(12px);
			        -webkit-backdrop-filter: blur(12px);

			        padding: calc(14px + var(--safe-top)) calc(14px + var(--safe-right)) calc(14px + var(--safe-bottom)) calc(14px + var(--safe-left));

			        opacity: 0;
			        visibility: hidden;
			        pointer-events: none;

			        transform: var(--gpu);
			        transition:
			            opacity 240ms ease,
			            visibility 0s linear 240ms;
			        isolation: isolate;
			    }

			    .nav-loading.show {
			        opacity: 1;
			        visibility: visible;
			        pointer-events: auto;
			        transition:
			            opacity 240ms ease,
			            visibility 0s;
			    }

			    .nav-loading-card {
			        width: min(520px, calc(100vw - 28px));
			        border-radius: 18px;
			        border: 1px solid rgba(255, 255, 255, 0.1);
			        background: radial-gradient(520px 240px at 18% 10%, rgba(255, 255, 255, 0.05), transparent 62%),
			            linear-gradient(135deg, rgba(6, 18, 14, 0.98), rgba(7, 30, 22, 0.96));
			        box-shadow: 0 25px 90px rgba(0, 0, 0, 0.64);
			        padding: 18px 18px;
			        display: flex;
			        gap: 12px;
			        align-items: center;
			        transform: translateY(4px);
			        transition: transform 240ms ease;
			    }

			    .nav-loading.show .nav-loading-card {
			        transform: translateY(0);
			    }

			    .nav-spinner {
			        width: 34px;
			        height: 34px;
			        border-radius: 999px;
			        border: 3px solid rgba(255, 255, 255, 0.14);
			        border-top-color: rgba(59, 224, 123, 0.9);
			        animation: navSpin 820ms linear infinite;
			        flex: 0 0 auto;
			    }

			    @keyframes navSpin {
			        to {
			            transform: rotate(360deg);
			        }
			    }

			    .nav-title {
			        font-weight: 1000;
			        color: rgba(255, 255, 255, 0.94);
			        line-height: 1.2;
			    }

			    .nav-sub {
			        font-size: 0.92rem;
			        color: rgba(255, 255, 255, 0.62);
			        margin-top: 2px;
			    }

			    /* =========================
					   * ACCESSIBILITY + REDUCED MOTION
					   * ======================= */
			    :focus-visible {
			        outline: 3px solid var(--ring);
			        outline-offset: 3px;
			        border-radius: 10px;
			    }

			    /* =========================
					   * LOW-END DOWNGRADE (auto by JS)
					   * ======================= */
			    body.low-end #fxCanvas {
			        opacity: 0.52;
			    }

			    body.low-end::after {
			        opacity: 0.028;
			    }

			    body.low-end .wheel-container::after {
			        opacity: 0.35;
			        filter: blur(0.9px);
			    }

			    body.low-end .wheel-outer {
			        box-shadow:
			            0 22px 70px rgba(0, 0, 0, 0.58),
			            0 0 26px rgba(243, 178, 74, 0.09);
			    }

			    body.low-end .wheel-corefx {
			        opacity: 0.78;
			        filter: blur(0.5px);
			    }

			    @supports (-webkit-touch-callout: none) {

			        /* Safari safety: tone down blend a bit to avoid harsh/patchy rendering */
			        .wheel-corefx {
			            opacity: 0.88;
			        }

			        header::after {
			            opacity: 0.46;
			        }
			    }

			    @media (prefers-reduced-motion: reduce) {
			        * {
			            animation: none !important;
			            transition: none !important;
			            scroll-behavior: auto !important;
			        }

			        .winners-table-row.is-new::after {
			            display: none !important;
			        }

			        .nav-spinner {
			            animation: none !important;
			        }

			        #fxCanvas {
			            display: none !important;
			        }

			        .wheel-outer::before {
			            display: none !important;
			        }

			        .wheel-container::after {
			            display: none !important;
			        }

			        body::after {
			            display: none !important;
			        }

			        .wheel-corefx {
			            display: none !important;
			        }
			    }
		</style>
	</head>

	<body>
		<canvas id="fxCanvas" aria-hidden="true"></canvas>

		<div class="container" id="mainContainer">
			<header>
				<h1 class="hero-title">
					<span class="hero-top">SELAMAT DATANG DI</span>
					<span class="hero-brand">MADETOTO2</span>
				</h1>
				<p class="subtitle">PUTAR RODANYA &amp; DAPATKAN HADIAH FANTASTIS HINGGA 200 RIBU RUPIAH!</p>
			</header>

			<div class="main-content">
				<!-- WHEEL -->
				<div class="wheel-container">
					<div class="wheel-wrapper" id="wheelWrap">
						<div class="pointer" id="pointerEl" aria-hidden="true">
							<!-- Pointer SVG (rapi + ID gradient diprefix biar aman) -->
							<svg viewBox="0 0 64 90" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
								<defs>
									<linearGradient id="mt2_pointer_metal" x1="0" y1="0" x2="0" y2="1">
										<stop offset="0" stop-color="rgba(255,255,255,0.90)" />
										<stop offset="0.24" stop-color="rgba(195,195,195,0.92)" />
										<stop offset="0.56" stop-color="rgba(88,88,88,0.96)" />
										<stop offset="1" stop-color="rgba(18,18,18,0.98)" />
									</linearGradient>

									<linearGradient id="mt2_pointer_gold" x1="0" y1="0" x2="0" y2="1">
										<stop offset="0" stop-color="#FFF4D6" />
										<stop offset="0.52" stop-color="#F6B33D" />
										<stop offset="1" stop-color="#8A4A16" />
									</linearGradient>

									<radialGradient id="mt2_pointer_cap" cx="35%" cy="30%" r="70%">
										<stop offset="0" stop-color="rgba(255,255,255,0.98)" />
										<stop offset="0.45" stop-color="#FFF4D6" />
										<stop offset="1" stop-color="#B45309" />
									</radialGradient>
								</defs>

								<path d="M32 86 L10 34 C10 34 14 10 32 10 C50 10 54 34 54 34 L32 86 Z" fill="url(#mt2_pointer_gold)" stroke="rgba(255,255,255,0.22)" stroke-width="2" />
								<path d="M32 80 L18 36 C18 36 20 18 32 18 C44 18 46 36 46 36 L32 80 Z" fill="url(#mt2_pointer_metal)" opacity="0.96" />
								<circle cx="32" cy="27" r="11" fill="url(#mt2_pointer_cap)" stroke="rgba(0,0,0,0.22)" stroke-width="2" />
								<circle cx="32" cy="27" r="4.2" fill="rgba(10,10,10,0.78)" stroke="rgba(255,255,255,0.16)" stroke-width="1.5" />
							</svg>
						</div>

						<div class="wheel-outer">
							<div class="wheel-inner" id="wheel" aria-label="Lucky wheel">
								<div class="wheel-corefx" aria-hidden="true"></div>
								<div class="wheel-center" aria-hidden="true">
									<span class="hub-sheen" aria-hidden="true"></span>
								</div>
							</div>
						</div>
					</div>
				</div>

				<!-- RIGHT SIDE -->
				<div>
					<div class="input-section">
						<h2>MASUKKAN USER ID</h2>
						<p>Masukkan User ID Anda untuk memutar roda keberuntungan.</p>

						<label for="userIdInput">User ID</label>
						<input id="userIdInput" type="text" placeholder="Contoh: User123" maxlength="20" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" inputmode="text" />

						<button id="spinBtn" class="primary-btn" type="button">SPIN SEKARANG!</button>

						<div class="jackpot-display" aria-live="polite">
							<div class="jackpot-label">Total Jackpot</div>
							<div class="jackpot-amount" id="jackpot">IDR 888.888.888</div>
							<div class="jackpot-meta" id="jackpotMeta">Update: --:--:--</div>
						</div>
					</div>

					<div id="spunMessage" class="spun-message" style="display: none">
						Kesempatan spin Anda sudah habis. Silakan klaim hadiah Anda.
					</div>

					<div class="winners-section">
						<div class="winners-header">🏆 50 Riwayat Spin Terakhir</div>
						<div class="winners-table" id="winnersTable" aria-live="polite">
							<div class="winners-table-header">
								<div>NO</div>
								<div>USER ID</div>
								<div>HADIAH</div>
							</div>
						</div>
					</div>
				</div>
			</div>
			<!-- /.main-content -->
		</div>
		<!-- /.container -->

		<!-- TOAST -->
		<div class="toast" id="toast" role="status" aria-live="polite" aria-atomic="true">
			<div class="dot" aria-hidden="true"></div>
			<div class="msg" id="toastMsg">Toast</div>
		</div>

		<!-- MODAL REWARD (NO SVG) -->
		<div class="modal" id="prizeModal" role="dialog" aria-modal="true" aria-labelledby="prizeTitle" aria-hidden="true">
			<div class="modal-content modal-reward" role="document">
				<div class="reward-hero">
					<div class="reward-hero-copy">
						<h1 id="prizeTitle">SELAMAT!</h1>
						<p class="reward-sub">Anda memenangkan hadiah:</p>
						<div class="prize-amount" id="prizeAmount">BONUS 10%</div>
					</div>
				</div>

				<div class="prize-meta">
					User ID: <span class="mono" id="modalUserId">-</span><br />
					Waktu: <span class="mono" id="modalTime">-</span>
				</div>

				<p style="margin-top: 12px">Silakan klaim melalui Live Chat dan sertakan User ID</p>

				<div class="share-wrap" aria-label="Bagikan hasil reward">
					<button type="button" class="share-one" id="shareBtn">BAGIKAN</button>
					<div class="share-hint">Klik untuk bagikan ke semua sosial media</div>
				</div>

				<div class="modal-actions">
					<button type="button" class="primary-btn" id="claimBtn">KLAIM SEKARANG</button>
					<button type="button" class="secondary-btn" id="downloadBtn">UNDUH HASIL</button>
				</div>

				<div class="prize-meta" style="margin-top: 10px">
					Klik unduh file akan tersimpan otomatis di perangkat Anda
				</div>
			</div>
		</div>

		<!-- NAV LOADING -->
		<div class="nav-loading" id="navLoading" aria-hidden="true">
			<div class="nav-loading-card" role="status" aria-live="polite" aria-atomic="true">
				<div class="nav-spinner" aria-hidden="true"></div>
				<div>
					<div class="nav-title">Menghubungkan…</div>
					<div class="nav-sub">Mengarahkan ke halaman Server</div>
				</div>
			</div>
		</div>

		<!-- Chaport Live Chat -->
		<script type="text/javascript">
			(function(w, d, v3) {
			    w.chaportConfig = {
			        appId: "6937b4ead2823b3f94b0a834"
			    };
			    if (w.chaport) return;
			    v3 = w.chaport = {};
			    v3._q = [];
			    v3._l = {};
			    v3.q = function() {
			        v3._q.push(arguments);
			    };
			    v3.on = function(e, fn) {
			        if (!v3._l[e]) v3._l[e] = [];
			        v3._l[e].push(fn);
			    };
			    var s = d.createElement("script");
			    s.type = "text/javascript";
			    s.async = true;
			    s.src = "https://app.chaport.com/javascripts/insert.js";
			    var ss = d.getElementsByTagName("script")[0];
			    ss.parentNode.insertBefore(s, ss);
			})(window, document, 0);
		</script>

		<!-- Audio -->
		<audio id="bgMusic" loop playsinline preload="auto"></audio>
		<audio id="spinSound" playsinline preload="auto"></audio>
		<audio id="tickSound" playsinline preload="auto"></audio>
		<audio id="winSound" playsinline preload="auto"></audio>
		<audio id="historySound" playsinline preload="auto"></audio>

		<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.0/dist/confetti.browser.min.js"></script>

		<script>
			        /* ======================================================================
			         * FULL PATCH — READY REPLACE (rapi + optimized)
			         * ✅ Smooth mobile/desktop + visual lebih tajam
			         * ✅ Sound spin & tick SINKRON dengan kecepatan roda (RAF driver, bukan setTimeout)
			         * ✅ Auto-scroll fokus ke Wheel setelah klik SPIN (tanpa ganggu desktop)
			         * ====================================================================== */

			        (() => {
			            "use strict";

			            // Prevent double-init (bfcache/pageshow/script injected twice)
			            const ROOT = document.documentElement;
			            if (ROOT && ROOT.dataset && ROOT.dataset.mt2SpinInit === "1") return;
			            if (ROOT && ROOT.dataset) ROOT.dataset.mt2SpinInit = "1";

			            // =========================
			            // CONFIG
			            // =========================
			            const CONFIG = {
			                // baseline (akan di-auto-sync jika metadata audio tersedia)
			                SPIN_DURATION_MS: 7800,
			                SPIN_DURATION_MIN_MS: 6800,
			                SPIN_DURATION_MAX_MS: 9800,
			                SPIN_DURATION_SYNC_TO_AUDIO: true,

			                CLAIM_URL: "https://newmadetoto2.com/",
			                CLAIM_OVERLAY_MIN_MS: 700,

			                LS_PREFIX: "mt2_spin_v2:",
			                PRIZES: ["25K", "50K", "75K", "100K", "200K", "BONUS 10%"],
			                BONUS_LABEL: "BONUS 10%",

			                PRIZE_DISPLAY_MAP: {
			                    "25K": "IDR 25.000",
			                    "50K": "IDR 50.000",
			                    "75K": "IDR 75.000",
			                    "100K": "IDR 100.000",
			                    "200K": "IDR 200.000",
			                    "BONUS 10%": "BONUS 10%",
			                },

			                // Wheel calibration
			                WHEEL: {
			                    START_OFFSET_DEG: 0,
			                    POINTER_AT_DEG: 0,
			                    JITTER_SEGMENT_FRAC: 0.55,
			                    FULL_SPINS_MIN: 9,
			                    FULL_SPINS_EXTRA: 5,
			                },

			                // Easing (must match wheel animation timing)
			                SPIN_EASING: {
			                    x1: 0.12,
			                    y1: 0.82,
			                    x2: 0.18,
			                    y2: 1.0
			                },

			                SCROLL: {
			                    ENABLED: true,
			                    OFFSET_PX: 18,
			                    FOCUS_CLASS_MS: 1100,
			                },

			                HISTORY: {
			                    SEED_COUNT: 50,
			                    KEEP_MAX: 50,
			                    UNIQUE_MASK_KEEP: 70,
			                    LIVE_MIN_MS: 5200,
			                    LIVE_MAX_MS: 12500,
			                    NON_USER_TOAST_COOLDOWN_MS: 1800,
			                    META_TICK_MS: 15000,
			                    FLIP_SCROLL_GUARD_MS: 140,
			                },

			                JACKPOT: {
			                    MIN: 800_000_000,
			                    SEED_MIN: 880_000_000,
			                    SEED_MAX: 930_000_000,
			                    SPEED_MIN: 1400,
			                    SPEED_MAX: 9500,
			                    SAVE_MS: 3000,
			                    SPIKE_CHANCE: 0.0012,
			                    SPIKE_MIN_MUL: 2.0,
			                    SPIKE_EXTRA_MUL: 2.3,
			                    SPIKE_MIN_MS: 2000,
			                    SPIKE_EXTRA_MS: 2500,
			                    NOISE: 0.8,
			                    NEG_CHANCE: 0.03,
			                    NEG_MUL: -0.25,
			                    DT_CAP: 0.22,
			                },

			                AUDIO: {
			                    bg: "https://cdn.pixabay.com/download/audio/2022/03/24/audio_197846c632.mp3?filename=casino-music-1-2518.mp3",
			                    spin: "https://assets.mixkit.co/active_storage/sfx/2003/2003-preview.mp3",
			                    win: "https://assets.mixkit.co/active_storage/sfx/2019/2019-preview.mp3",
			                    tick: "https://assets.mixkit.co/active_storage/sfx/2063/2063-preview.mp3",
			                    history: "https://assets.mixkit.co/active_storage/sfx/2014/2014-preview.mp3",

			                    vol: {
			                        bg: 0.22,
			                        spin: 0.6,
			                        win: 0.85,
			                        tick: 0.55,
			                        history: 0.62
			                    },

			                    TICK_POOL: 7, // sedikit dinaikkan biar aman saat overlap kecil
			                    HISTORY_POOL: 4,
			                    HISTORY_SFX_GAP_MS: 700,

			                    // spin loop + fade-out
			                    SPIN_LOOP: true,
			                    SPIN_FADE_OUT_MS: 950,

			                    // ✅ HARD SYNC: durasi spin dibulatkan agar “stop” terasa pas (loop boundary)
			                    SPIN_SYNC_TO_SFX: true,
			                    SPIN_TARGET_LOOPS_MIN: 2,
			                    SPIN_TARGET_LOOPS_MAX: 5,
			                    SPIN_FADE_OUT_MAX_FRAC: 0.65, // fade max 65% dari 1 loop sfx

			                    // ✅ sync feeling (tuning)
			                    SPIN_RATE_MIN: 0.90,
			                    SPIN_RATE_MAX: 1.35,
			                    SPIN_RATE_SPEED_REF: 1.05, // deg/ms reference untuk normalisasi speed

			                    // ✅ smoothing playbackRate (hindari flutter)
			                    SPIN_RATE_UPDATE_MS: 60, // update rate tiap ~60ms (bukan tiap frame)
			                    SPIN_RATE_SMOOTHING: 0.18, // lerp strength

			                    // ✅ tick feel “casino mechanical”
			                    TICK_LATENCY_MS: 0, // jika terasa telat dikit, set -6 sampai -12 (ms)
			                    TICK_DECEL: {
			                        ENABLED: true,
			                        END_WINDOW_FRAC: 0.30, // 0.20–0.35: area akhir yg dibuat “soft”
			                        JITTER_MS: 6, // micro jitter (0–10)
			                        END_VOL_MUL: 0.78,
			                        END_PITCH_MUL: 0.92,
			                        END_INTENSITY_MUL: 0.82,
			                        SOFTEN_CURVE: 1.35,
			                    },
			                    // ✅ final “settle tap” (pointer settle di ujung, bikin real banget)
			                    TICK_SETTLE_TAP: {
			                        ENABLED: true,
			                        LAST_N_TICKS: 2,
			                        DELAY_MIN_MS: 26,
			                        DELAY_MAX_MS: 46,
			                        VOL_MUL: 0.36,
			                        PITCH_MUL: 0.88,
			                        INTENSITY_MUL: 0.55,
			                    },
			                },

			                PNG: {
			                    BASE_W: 1080,
			                    DPR_CAP: 2,
			                    NOTE_TEXT: "Silakan klaim melalui Live Chat dan sertakan USER ID + hasil unduh ini.",
			                    NOTE_MAX_LINES: 3,
			                },
			            };

			            const LS = {
			                HAS_SPUN: CONFIG.LS_PREFIX + "hasSpun",
			                SPIN_AT: CONFIG.LS_PREFIX + "spinAt",
			                LAST_USER_ID: CONFIG.LS_PREFIX + "lastUserId",
			                JACKPOT_VAL: CONFIG.LS_PREFIX + "jackpotVal",
			                ROTATION: CONFIG.LS_PREFIX + "rotation",
			            };

			            // =========================
			            // UTIL
			            // =========================
			            const $ = (id) => document.getElementById(id);

			            const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
			            const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
			            const rand = (a, b) => a + Math.random() * (b - a);
			            const pad2 = (n) => String(n).padStart(2, "0");

			            function lsGet(key, fallback = "") {
			                try {
			                    const v = localStorage.getItem(key);
			                    return v == null ? fallback : v;
			                } catch (_) {
			                    return fallback;
			                }
			            }

			            function lsSet(key, value) {
			                try {
			                    localStorage.setItem(key, String(value));
			                } catch (_) {}
			            }

			            function normalizeUserIdInput(v) {
			                return String(v == null ? "" : v)
			                    .trim()
			                    .replace(/\s+/g, "")
			                    .replace(/[^A-Za-z0-9_-]/g, "")
			                    .slice(0, 20);
			            }

			            function isReducedMotion() {
			                return !!(window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches);
			            }

			            function detectLowEnd() {
			                try {
			                    const devMem = Number(navigator.deviceMemory || 0) || 0;
			                    const cores = Number(navigator.hardwareConcurrency || 0) || 0;
			                    const saveData = !!(navigator.connection && navigator.connection.saveData);
			                    const low = saveData || (devMem && devMem <= 2) || (cores && cores <= 4);
			                    if (low) document.body.classList.add("low-end");
			                    return !!low;
			                } catch (_) {
			                    return false;
			                }
			            }

			            function migrateLegacyKeys() {
			                const legacy = {
			                    hasSpun: "hasSpun",
			                    spinAt: "spinAt",
			                    lastUserId: "lastUserId",
			                    jackpotVal: "jackpotVal",
			                    rotation: "rotation",
			                };
			                if (!lsGet(LS.HAS_SPUN, "") && lsGet(legacy.hasSpun, "")) lsSet(LS.HAS_SPUN, lsGet(legacy.hasSpun, ""));
			                if (!lsGet(LS.SPIN_AT, "") && lsGet(legacy.spinAt, "")) lsSet(LS.SPIN_AT, lsGet(legacy.spinAt, ""));
			                if (!lsGet(LS.LAST_USER_ID, "") && lsGet(legacy.lastUserId, "")) lsSet(LS.LAST_USER_ID, lsGet(legacy.lastUserId, ""));
			                if (!lsGet(LS.JACKPOT_VAL, "") && lsGet(legacy.jackpotVal, "")) lsSet(LS.JACKPOT_VAL, lsGet(legacy.jackpotVal, ""));
			                if (!lsGet(LS.ROTATION, "") && lsGet(legacy.rotation, "")) lsSet(LS.ROTATION, lsGet(legacy.rotation, ""));
			            }

			            // =========================
			            // EASING cubic-bezier + inverse
			            // =========================
			            function makeCubicBezier(x1, y1, x2, y2) {
			                const cx = 3 * x1,
			                    bx = 3 * (x2 - x1) - cx,
			                    ax = 1 - cx - bx;
			                const cy = 3 * y1,
			                    by = 3 * (y2 - y1) - cy,
			                    ay = 1 - cy - by;

			                const sampleX = (t) => ((ax * t + bx) * t + cx) * t;
			                const sampleY = (t) => ((ay * t + by) * t + cy) * t;
			                const sampleDX = (t) => (3 * ax * t + 2 * bx) * t + cx;

			                function solveTForX(x) {
			                    let t = x;
			                    for (let i = 0; i < 8; i++) {
			                        const x2 = sampleX(t) - x;
			                        const d = sampleDX(t);
			                        if (Math.abs(x2) < 1e-6) return t;
			                        if (Math.abs(d) < 1e-6) break;
			                        t = t - x2 / d;
			                    }
			                    let lo = 0,
			                        hi = 1;
			                    t = x;
			                    for (let i = 0; i < 18; i++) {
			                        const x2 = sampleX(t);
			                        if (Math.abs(x2 - x) < 1e-6) return t;
			                        if (x > x2) lo = t;
			                        else hi = t;
			                        t = (lo + hi) * 0.5;
			                    }
			                    return t;
			                }

			                const ease = (x) => {
			                    x = clamp(x, 0, 1);
			                    const t = solveTForX(x);
			                    return sampleY(t);
			                };

			                const inv = (p) => {
			                    p = clamp(p, 0, 1);
			                    let lo = 0,
			                        hi = 1;
			                    for (let i = 0; i < 22; i++) {
			                        const mid = (lo + hi) * 0.5;
			                        const v = ease(mid);
			                        if (v < p) lo = mid;
			                        else hi = mid;
			                    }
			                    return (lo + hi) * 0.5;
			                };

			                return {
			                    ease,
			                    inv
			                };
			            }

			            const EASING = makeCubicBezier(
			                CONFIG.SPIN_EASING.x1,
			                CONFIG.SPIN_EASING.y1,
			                CONFIG.SPIN_EASING.x2,
			                CONFIG.SPIN_EASING.y2
			            );
			            const SPIN_EASING_CSS = `cubic-bezier(${CONFIG.SPIN_EASING.x1},${CONFIG.SPIN_EASING.y1},${CONFIG.SPIN_EASING.x2},${CONFIG.SPIN_EASING.y2})`;

			            // numeric derivative (for speed feel)
			            function _mt2EaseDeriv(p) {
			                const e = 0.0012;
			                const p0 = clamp(p - e, 0, 1);
			                const p1 = clamp(p + e, 0, 1);
			                const d = (EASING.ease(p1) - EASING.ease(p0)) / Math.max(1e-6, (p1 - p0));
			                return clamp(d, 0, 10);
			            }

			            // =========================
			            // STATE
			            // =========================
			            const PRIZES = CONFIG.PRIZES.slice();
			            const BONUS_LABEL = CONFIG.BONUS_LABEL;
			            const BONUS_INDEX = PRIZES.indexOf(BONUS_LABEL);

			            const STATE = {
			                hasSpun: false,
			                spinAt: 0,
			                savedUserId: "",
			                currentRotation: 0,

			                isSpin: false,
			                lastResult: null,

			                winners: [],
			                winnersById: new Map(),
			                rowElById: new Map(),
			                lastOrderKey: "",
			                lastScrollAt: 0,

			                liveTimer: 0,
			                toastTimer: 0,
			                metaTimer: 0,
			                metaTickerStarted: false,

			                jackpotTimer: 0,
			                jackpotSaveTimer: 0,
			                jackpot: 0,
			                spikeUntilMs: 0,
			                spikeMul: 1,

			                lastFocusedEl: null,

			                tickPool: [],
			                tickPoolIdx: 0,
			                historyPool: [],
			                historyPoolIdx: 0,
			                historySfxAt: 0,
			                audioPrimed: false,
			                bgStarted: false,

			                pointerEl: null,
			                pointerKickT: 0,

			                spinToken: 0,
			                spinAudioRaf: 0,
			                spinTickTimers: [],
			                spinMeta: {
			                    t0: 0,
			                    tEnd: 0,
			                    absDelta: 0,
			                    seg: 0
			                },

			                recentMasked: new Set(),
			                recentMaskedQueue: [],

			                pauseReasons: new Set(),
			                inertReasons: new Set(),

			                nonUserToastAt: 0,
			            };

			            // =========================
			            // Pause / inert / body lock
			            // =========================
			            function stopLiveHistory() {
			                if (STATE.liveTimer) clearTimeout(STATE.liveTimer);
			                STATE.liveTimer = 0;
			            }

			            function pauseHistory(reason) {
			                STATE.pauseReasons.add(String(reason || "x"));
			                stopLiveHistory();
			            }

			            function resumeHistory(reason) {
			                STATE.pauseReasons.delete(String(reason || "x"));
			                if (STATE.pauseReasons.size === 0 && !document.hidden) startLiveHistory();
			            }

			            function setInert(reason, on) {
			                const main = $("mainContainer");
			                if (!main) return;

			                const r = String(reason || "x");
			                if (on) STATE.inertReasons.add(r);
			                else STATE.inertReasons.delete(r);

			                const should = STATE.inertReasons.size > 0;

			                try {
			                    if (should) {
			                        main.setAttribute("inert", "");
			                        main.setAttribute("aria-hidden", "true");
			                    } else {
			                        main.removeAttribute("inert");
			                        main.removeAttribute("aria-hidden");
			                    }
			                } catch (_) {}

			                main.classList.toggle("is-inert-fallback", should);
			            }

			            function setBodyLock(on) {
			                document.body.classList.toggle("modal-open", !!on);
			            }

			            // =========================
			            // TOAST
			            // =========================
			            function showToast(message, type = "info", ms = 2400) {
			                const toast = $("toast");
			                const msg = $("toastMsg");
			                if (!toast || !msg) return;

			                toast.classList.remove("error", "success");
			                if (type === "error") toast.classList.add("error");
			                if (type === "success") toast.classList.add("success");

			                msg.textContent = String(message || "");
			                toast.classList.add("show");

			                clearTimeout(STATE.toastTimer);
			                STATE.toastTimer = setTimeout(() => toast.classList.remove("show"), ms);
			            }

			            // =========================
			            // ENHANCE STYLES (Reward modal + Share + Wheel Focus + Sharpen)
			            // =========================
			            function ensureEnhanceStyles() {
			                if (document.getElementById("mt2-enhance-style")) return;
			                const style = document.createElement("style");
			                style.id = "mt2-enhance-style";
			                style.textContent = `
			.modal-content.modal-reward{max-width:520px}
			.reward-hero{display:flex;align-items:flex-start;gap:14px;margin-bottom:10px}
			.reward-gift{flex:0 0 auto;filter: drop-shadow(0 16px 28px rgba(0,0,0,.45))}
			.reward-hero-copy{min-width:0;flex:1}
			.reward-sub{margin:2px 0 8px 0;opacity:.82}

			.share-wrap{ margin-top:14px; padding-top:12px; border-top:1px solid rgba(255,255,255,.10); }
			.share-one{
			  width:100%;
			  border:1px solid rgba(34,197,94,.35);
			  background: linear-gradient(180deg, rgba(34,197,94,.20), rgba(34,197,94,.10));
			  color: rgba(255,255,255,.94);
			  font-weight: 1000;
			  letter-spacing:.6px;
			  padding:12px 14px;
			  border-radius:14px;
			  cursor:pointer;
			  transition: transform .12s ease, filter .12s ease, background .12s ease, border-color .12s ease, opacity .12s ease;
			  user-select:none;
			  box-shadow: 0 18px 34px rgba(0,0,0,.35);
			}
			.share-one:hover{
			  filter: brightness(1.06);
			  border-color: rgba(34,197,94,.55);
			  background: linear-gradient(180deg, rgba(34,197,94,.26), rgba(34,197,94,.12));
			}
			.share-one:active{transform: translateY(1px)}
			.share-one:disabled{opacity:.55;cursor:not-allowed}
			.share-hint{margin-top:8px;opacity:.70;font-size:12px;line-height:1.35}

			@keyframes mt2WheelPulse{
			  0%{ box-shadow: 0 0 0 1px rgba(34,197,94,.18), 0 0 0 0 rgba(34,197,94,.00), 0 28px 56px rgba(0,0,0,.50); }
			  45%{ box-shadow: 0 0 0 1px rgba(34,197,94,.32), 0 0 0 12px rgba(34,197,94,.08), 0 32px 64px rgba(0,0,0,.55); }
			  100%{ box-shadow: 0 0 0 1px rgba(34,197,94,.18), 0 0 0 0 rgba(34,197,94,.00), 0 28px 56px rgba(0,0,0,.50); }
			}
			#wheelWrap.mt2-focus .wheel-outer{ animation: mt2WheelPulse .95s ease-out 1; border-radius: 999px; }

			#wheel{ backface-visibility:hidden; -webkit-backface-visibility:hidden; transform-origin:50% 50%; }
			#wheel, #wheel .prize-text{ -webkit-font-smoothing: antialiased; text-rendering: geometricPrecision; }
			#wheel .prize-text{ will-change: transform; }
			@media (prefers-reduced-motion: reduce){
			  #wheelWrap.mt2-focus .wheel-outer{ animation: none !important; }
			}
			`;
			                document.head.appendChild(style);
			            }

// =========================
// AUTO-SCROLL FOCUS WHEEL (POWER-UP)
// =========================
let _focusWheelCooldownT = 0;
let _focusWheelGlowT = 0;
let _userScrollHotUntil = 0;

(function bindUserScrollIntentGuard(){
  // sekali saja; kalau sudah ada sistem lain, boleh hapus blok ini
  const mark = () => { _userScrollHotUntil = Date.now() + 700; };
  window.addEventListener("wheel", mark, { passive: true });
  window.addEventListener("touchmove", mark, { passive: true });
})();

function focusWheelIntoView() {
  if (!CONFIG.SCROLL.ENABLED) return;

  // anti-spam
  const now = Date.now();
  const cd = Math.max(0, Number(CONFIG.SCROLL.COOLDOWN_MS || 450));
  if (_focusWheelCooldownT && now < _focusWheelCooldownT) return;
  _focusWheelCooldownT = now + cd;

  // hormati user kalau lagi scroll manual
  if (now < _userScrollHotUntil && !CONFIG.SCROLL.FORCE_WHEN_USER_SCROLLING) return;

  const target = $("wheelWrap") || $("wheel");
  if (!target) return;

  // highlight fokus (rapi timer)
  try {
    if (_focusWheelGlowT) clearTimeout(_focusWheelGlowT);
    target.classList.add("mt2-focus");
    _focusWheelGlowT = setTimeout(() => {
      try { target.classList.remove("mt2-focus"); } catch (_) {}
    }, Math.max(0, Number(CONFIG.SCROLL.FOCUS_CLASS_MS || 650)));
  } catch (_) {}

  let rect = null;
  try { rect = target.getBoundingClientRect(); } catch (_) {}

  const vv = window.visualViewport || null;
  const vh = Math.max(1, (vv && vv.height) ? vv.height : (window.innerHeight || 0));
  const scrollY = window.pageYOffset || document.documentElement.scrollTop || 0;

  // threshold in-view (nggak harus 100% masuk)
  const padTop = Number(CONFIG.SCROLL.PAD_TOP_PX || 0) || 0;
  const padBottom = Number(CONFIG.SCROLL.PAD_BOTTOM_PX || 0) || 0;
  const visibleTop = 0 + padTop;
  const visibleBot = vh - padBottom;

  // kalau rect belum ada, fallback scroll ke id
  if (!rect) {
    const behavior = isReducedMotion() ? "auto" : "smooth";
    try { target.scrollIntoView({ behavior, block: "center", inline: "nearest" }); } catch (_) {}
    return;
  }

  const rectH = Math.max(1, rect.height || 1);
  const visibleH = Math.max(1, Math.min(rect.bottom, visibleBot) - Math.max(rect.top, visibleTop));
  const visibleRatio = visibleH / rectH;

  const minRatio = Math.min(1, Math.max(0, Number(CONFIG.SCROLL.MIN_VISIBLE_RATIO || 0.78)));
  if (visibleRatio >= minRatio) return;

  const behavior = isReducedMotion() ? "auto" : "smooth";

  // hitung targetY sekali (lebih stabil daripada scrollIntoView + scrollBy)
  const stickyTop = Number(CONFIG.SCROLL.STICKY_TOP_PX || 0) || 0;   // header sticky
  const offset = Number(CONFIG.SCROLL.OFFSET_PX || 0) || 0;          // offset tambahan kamu
  const vvTop = (vv && typeof vv.offsetTop === "number") ? vv.offsetTop : 0;

  // kita mau posisi "center" tapi dikoreksi sticky + offset
  const targetCenterInViewport = (vh / 2) + vvTop;
  const rectCenter = rect.top + (rectH / 2);

  // delta scroll supaya rect center pindah ke targetCenterInViewport
  const delta = rectCenter - targetCenterInViewport;

  // top baru = scrollY + delta - stickyTop - offset
  const nextY = Math.max(0, Math.round(scrollY + delta - stickyTop - offset));

  try {
    window.scrollTo({ top: nextY, behavior });
  } catch (_) {
    try { window.scrollTo(0, nextY); } catch (_) {}
  }
}

			            // =========================
			            // AUDIO (sync + pools + casino feel)
			            // =========================
			            function _mt2ApplySpinDuration(ms) {
			                ms = Math.round(Number(ms) || CONFIG.SPIN_DURATION_MS);
			                ms = clamp(ms, CONFIG.SPIN_DURATION_MIN_MS, CONFIG.SPIN_DURATION_MAX_MS);
			                CONFIG.SPIN_DURATION_MS = ms;

			                // keep CSS var in sync if you use it in CSS
			                try {
			                    const wheel = $("wheel");
			                    if (wheel) wheel.style.setProperty("--spin-dur", ms + "ms");
			                } catch (_) {}
			            }

			            function _mt2SyncSpinDurationToSfx() {
			                if (!CONFIG.SPIN_DURATION_SYNC_TO_AUDIO || !CONFIG.AUDIO.SPIN_SYNC_TO_SFX) return;

			                const spinSound = $("spinSound");
			                if (!spinSound) return;

			                const durS = Number(spinSound.duration || 0);
			                if (!Number.isFinite(durS) || durS <= 0.25) return;

			                const sfxMs = durS * 1000;

			                // clamp fade-out so it never feels like “cutting” the loop
			                const fadeMax = Math.max(220, sfxMs * clamp(CONFIG.AUDIO.SPIN_FADE_OUT_MAX_FRAC || 0.65, 0.35, 0.85));
			                CONFIG.AUDIO.SPIN_FADE_OUT_MS = Math.round(clamp(CONFIG.AUDIO.SPIN_FADE_OUT_MS || 950, 200, fadeMax));

			                const base = clamp(CONFIG.SPIN_DURATION_MS, CONFIG.SPIN_DURATION_MIN_MS, CONFIG.SPIN_DURATION_MAX_MS);
			                const loopsMin = Math.max(1, CONFIG.AUDIO.SPIN_TARGET_LOOPS_MIN | 0);
			                const loopsMax = Math.max(loopsMin, CONFIG.AUDIO.SPIN_TARGET_LOOPS_MAX | 0);

			                let loops = Math.round(base / sfxMs);
			                loops = clamp(loops, loopsMin, loopsMax);

			                let target = loops * sfxMs;

			                if (target < CONFIG.SPIN_DURATION_MIN_MS) target = Math.ceil(CONFIG.SPIN_DURATION_MIN_MS / sfxMs) * sfxMs;
			                if (target > CONFIG.SPIN_DURATION_MAX_MS) target = Math.floor(CONFIG.SPIN_DURATION_MAX_MS / sfxMs) * sfxMs;

			                target = clamp(target, CONFIG.SPIN_DURATION_MIN_MS, CONFIG.SPIN_DURATION_MAX_MS);
			                _mt2ApplySpinDuration(target);
			            }

			            function setupAudio() {
			                const bgMusic = $("bgMusic");
			                const spinSound = $("spinSound");
			                const tickSound = $("tickSound");
			                const winSound = $("winSound");
			                const historySound = $("historySound");
			                if (!bgMusic || !spinSound || !tickSound || !winSound || !historySound) return;

			                bgMusic.src = CONFIG.AUDIO.bg;
			                spinSound.src = CONFIG.AUDIO.spin;
			                winSound.src = CONFIG.AUDIO.win;
			                tickSound.src = CONFIG.AUDIO.tick;
			                historySound.src = CONFIG.AUDIO.history;

			                bgMusic.volume = CONFIG.AUDIO.vol.bg;
			                spinSound.volume = CONFIG.AUDIO.vol.spin;
			                winSound.volume = CONFIG.AUDIO.vol.win;
			                tickSound.volume = CONFIG.AUDIO.vol.tick;
			                historySound.volume = CONFIG.AUDIO.vol.history;

			                try {
			                    bgMusic.preload = "auto";
			                    spinSound.preload = "auto";
			                    tickSound.preload = "auto";
			                    winSound.preload = "auto";
			                    historySound.preload = "auto";
			                } catch (_) {}

			                // ✅ auto-sync duration to spin sfx metadata (once)
			                if (!spinSound.dataset.mt2MetaBound) {
			                    spinSound.dataset.mt2MetaBound = "1";
			                    const onMeta = () => {
			                        try {
			                            _mt2SyncSpinDurationToSfx();
			                        } catch (_) {}
			                    };
			                    spinSound.addEventListener("loadedmetadata", onMeta, {
			                        once: true
			                    });
			                    try {
			                        if (spinSound.readyState >= 1) onMeta();
			                    } catch (_) {}
			                }

			                // tick pool
			                STATE.tickPool = [];
			                for (let i = 0; i < CONFIG.AUDIO.TICK_POOL; i++) {
			                    const a = new Audio(tickSound.src);
			                    a.volume = tickSound.volume;
			                    a.preload = "auto";
			                    STATE.tickPool.push(a);
			                }

			                // history pool
			                STATE.historyPool = [];
			                for (let i = 0; i < CONFIG.AUDIO.HISTORY_POOL; i++) {
			                    const a = new Audio(historySound.src);
			                    a.volume = historySound.volume;
			                    a.preload = "auto";
			                    STATE.historyPool.push(a);
			                }
			            }

			            function primeAudioPool(pool) {
			                pool.forEach((a) => {
			                    try {
			                        const prevMuted = a.muted;
			                        a.muted = true;
			                        a.play().then(() => {
			                            a.pause();
			                            a.currentTime = 0;
			                            a.muted = prevMuted;
			                        }).catch(() => {
			                            a.muted = prevMuted;
			                        });
			                    } catch (_) {}
			                });
			            }

			            function kickAudio(withBgStart = false) {
			                if (!STATE.audioPrimed) {
			                    STATE.audioPrimed = true;
			                    primeAudioPool(STATE.tickPool);
			                    primeAudioPool(STATE.historyPool);
			                }
			                if (!withBgStart) return;

			                if (!STATE.bgStarted) {
			                    STATE.bgStarted = true;
			                    const bgMusic = $("bgMusic");
			                    if (bgMusic && bgMusic.paused) {
			                        bgMusic.play().then(() => {
			                            showToast("Audio aktif", "success", 1400);
			                        }).catch(() => {});
			                    }
			                }
			            }

			            function pointerKick(intensity = 1) {
			                if (!STATE.pointerEl) return;
			                if (STATE.pointerKickT) clearTimeout(STATE.pointerKickT);

			                const deg = (-8 - Math.random() * 6) * intensity; // -8..-14
			                STATE.pointerEl.style.setProperty("--kick-deg", deg.toFixed(2) + "deg");

			                STATE.pointerEl.classList.remove("is-kick");
			                requestAnimationFrame(() => {
			                    if (!STATE.pointerEl) return;
			                    STATE.pointerEl.classList.add("is-kick");
			                });

			                STATE.pointerKickT = setTimeout(() => {
			                    if (STATE.pointerEl) STATE.pointerEl.classList.remove("is-kick");
			                }, 140);
			            }

			            // ✅ tick 1:1 casino: volume/pitch/intensity bisa dimodif oleh scheduler
			            function playTick(intensity = 1, speedNorm = 0.5, opts) {
			                pointerKick(intensity);

			                const baseVol = Number(CONFIG.AUDIO.vol.tick || 0.55);
			                const o = opts && typeof opts === "object" ? opts : {};
			                const volMulExtra = Number.isFinite(o.volMul) ? o.volMul : 1;
			                const pitchMulExtra = Number.isFinite(o.pitchMul) ? o.pitchMul : 1;

			                const volMul = clamp((0.72 + speedNorm * 0.55) * volMulExtra, 0.45, 1.25);

			                let pitch = 0.98 + Math.random() * 0.06 + speedNorm * 0.12;
			                pitch *= pitchMulExtra;
			                pitch = clamp(pitch, 0.80, 1.30);

			                try {
			                    const a = STATE.tickPool[STATE.tickPoolIdx++ % STATE.tickPool.length];
			                    try {
			                        a.pause();
			                    } catch (_) {}
			                    try {
			                        a.currentTime = 0;
			                    } catch (_) {}
			                    try {
			                        a.volume = clamp(baseVol * volMul, 0, 1);
			                    } catch (_) {}
			                    try {
			                        a.playbackRate = pitch;
			                    } catch (_) {}
			                    a.play().catch(() => {});
			                } catch (_) {}
			            }

			            function playHistorySfx() {
			                const now = Date.now();
			                if (now - STATE.historySfxAt < CONFIG.AUDIO.HISTORY_SFX_GAP_MS) return;
			                STATE.historySfxAt = now;
			                try {
			                    const a = STATE.historyPool[STATE.historyPoolIdx++ % STATE.historyPool.length];
			                    a.currentTime = 0;
			                    a.play().catch(() => {});
			                } catch (_) {}
			            }

			            // =========================
			            // SPIN DRIVER — 1:1 casino real (ticks scheduled, decel feel, smooth spin rate)
			            // =========================
			            function _mt2ClearSpinTicks() {
			                if (STATE.spinTickTimers && STATE.spinTickTimers.length) {
			                    for (const t of STATE.spinTickTimers) clearTimeout(t);
			                }
			                STATE.spinTickTimers = [];
			            }

			            function stopSpinDriver(immediate = true) {
			                if (STATE.spinAudioRaf) cancelAnimationFrame(STATE.spinAudioRaf);
			                STATE.spinAudioRaf = 0;

			                _mt2ClearSpinTicks();

			                const spinSound = $("spinSound");
			                if (spinSound) {
			                    try {
			                        spinSound.loop = false;
			                    } catch (_) {}
			                    try {
			                        spinSound.playbackRate = 1;
			                    } catch (_) {}
			                    try {
			                        if (immediate) {
			                            spinSound.pause();
			                            spinSound.currentTime = 0;
			                        }
			                    } catch (_) {}
			                    try {
			                        spinSound.volume = Number(CONFIG.AUDIO.vol.spin || 0.6);
			                    } catch (_) {}
			                }
			            }

			            // alias compatible
			            function stopSpinSound(immediate = true) {
			                stopSpinDriver(immediate);
			            }

			            function _mt2ScheduleTicks(absDelta, seg, durationMs, token, speedRef) {
			                const timers = [];
			                const ticks = Math.max(0, Math.floor(absDelta / seg));
			                if (!ticks) return timers;

			                const dec = (CONFIG.AUDIO && CONFIG.AUDIO.TICK_DECEL) || {};
			                const DECEL_ON = !!dec.ENABLED;
			                const END_W = clamp(Number(dec.END_WINDOW_FRAC || 0.30), 0.12, 0.5);
			                const JITTER = clamp(Number(dec.JITTER_MS || 6), 0, 10);
			                const END_VOL = clamp(Number(dec.END_VOL_MUL || 0.78), 0.45, 1);
			                const END_PITCH = clamp(Number(dec.END_PITCH_MUL || 0.92), 0.75, 1.05);
			                const END_INT = clamp(Number(dec.END_INTENSITY_MUL || 0.82), 0.45, 1);
			                const CURVE = clamp(Number(dec.SOFTEN_CURVE || 1.35), 0.85, 2.2);

			                const settle = (CONFIG.AUDIO && CONFIG.AUDIO.TICK_SETTLE_TAP) || {};
			                const SETTLE_ON = !!settle.ENABLED;
			                const SETTLE_LAST = clamp(Number(settle.LAST_N_TICKS || 2), 0, 6);
			                const SETTLE_VOL = clamp(Number(settle.VOL_MUL || 0.36), 0.15, 0.75);
			                const SETTLE_PITCH = clamp(Number(settle.PITCH_MUL || 0.88), 0.65, 1.05);
			                const SETTLE_INT = clamp(Number(settle.INTENSITY_MUL || 0.55), 0.2, 1);
			                const SETTLE_DMIN = clamp(Number(settle.DELAY_MIN_MS || 26), 10, 120);
			                const SETTLE_DMAX = clamp(Number(settle.DELAY_MAX_MS || 46), SETTLE_DMIN, 160);

			                const endStart = 1 - END_W;
			                const LAT = clamp(Number(CONFIG.AUDIO.TICK_LATENCY_MS || 0), -24, 18);

			                for (let k = 1; k <= ticks; k++) {
			                    const frac = clamp((k * seg) / absDelta, 0, 1);
			                    const tFrac = EASING.inv(frac);

			                    let at = Math.round(tFrac * durationMs);

			                    // derivative -> speed feel
			                    const d = _mt2EaseDeriv(tFrac);
			                    const speed = (absDelta * d) / Math.max(1, durationMs); // deg/ms
			                    const speedNorm = clamp(speed / Math.max(0.35, speedRef), 0, 1);

			                    // decel modifiers near end
			                    let volMul = 1;
			                    let pitchMul = 1;
			                    let intensityMul = 1;

			                    if (DECEL_ON && tFrac >= endStart) {
			                        const phase = clamp((tFrac - endStart) / Math.max(1e-6, END_W), 0, 1);
			                        const s = Math.pow(phase, CURVE);
			                        volMul *= (1 + (END_VOL - 1) * s);
			                        pitchMul *= (1 + (END_PITCH - 1) * s);
			                        intensityMul *= (1 + (END_INT - 1) * s);
			                    }

			                    // micro-jitter (mechanical feel)
			                    if (JITTER > 0) {
			                        const j = ((Math.random() * 2 - 1) * JITTER) | 0;
			                        at = Math.max(0, at + j);
			                    }

			                    // bias to feel “on pointer”
			                    const delay = Math.max(0, at - 8 + LAT);

			                    timers.push(setTimeout(() => {
			                        if (token !== STATE.spinToken) return;

			                        const baseIntensity = clamp(0.42 + speedNorm * 0.68, 0.35, 1);
			                        const intensity = clamp(baseIntensity * intensityMul, 0.28, 1);

			                        playTick(intensity, speedNorm, {
			                            volMul,
			                            pitchMul
			                        });

			                        // settle tap for last N ticks (casino realism)
			                        if (SETTLE_ON && SETTLE_LAST > 0 && k > ticks - SETTLE_LAST) {
			                            const dly = Math.round(rand(SETTLE_DMIN, SETTLE_DMAX));
			                            timers.push(setTimeout(() => {
			                                if (token !== STATE.spinToken) return;
			                                playTick(
			                                    clamp(intensity * SETTLE_INT, 0.18, 0.8),
			                                    clamp(speedNorm * 0.7, 0, 1), {
			                                        volMul: volMul * SETTLE_VOL,
			                                        pitchMul: pitchMul * SETTLE_PITCH
			                                    }
			                                );
			                            }, dly));
			                        }
			                    }, delay));
			                }

			                return timers;
			            }

			            function startSpinDriver(startRot, rotationDelta, segmentAngleDeg, durationMs, token) {
			                if (isReducedMotion()) return;

			                stopSpinDriver(true);

			                const spinSound = $("spinSound");
			                const baseSpinVol = Number(CONFIG.AUDIO.vol.spin || 0.6);

			                const SPEED_REF = Math.max(0.35, Number(CONFIG.AUDIO.SPIN_RATE_SPEED_REF || 1.05));
			                const RATE_MIN = Number(CONFIG.AUDIO.SPIN_RATE_MIN || 0.90);
			                const RATE_MAX = Number(CONFIG.AUDIO.SPIN_RATE_MAX || 1.35);
			                const UPDATE_MS = clamp(Number(CONFIG.AUDIO.SPIN_RATE_UPDATE_MS || 60), 32, 120);
			                const SMOOTH = clamp(Number(CONFIG.AUDIO.SPIN_RATE_SMOOTHING || 0.18), 0.08, 0.40);

			                const seg = Math.max(1e-6, Math.abs(Number(segmentAngleDeg || 0)));
			                const absDelta = Math.abs(Number(rotationDelta || 0));
			                const fadeMs = Math.max(180, Number(CONFIG.AUDIO.SPIN_FADE_OUT_MS || 950) || 950);

			                const t0 = performance.now();
			                const tEnd = t0 + durationMs;
			                const tFade = tEnd - Math.min(fadeMs, durationMs * 0.52);

			                STATE.spinMeta = {
			                    t0,
			                    tEnd,
			                    absDelta,
			                    seg
			                };

			                // ✅ tick schedule is timeline-based (anti lag burst)
			                _mt2ClearSpinTicks();
			                STATE.spinTickTimers = _mt2ScheduleTicks(absDelta, seg, durationMs, token, SPEED_REF);

			                // spin sfx start
			                let curRate = 1.05;
			                let lastUpdate = t0;

			                if (spinSound) {
			                    try {
			                        spinSound.pause();
			                        spinSound.currentTime = 0;
			                    } catch (_) {}
			                    try {
			                        spinSound.volume = baseSpinVol;
			                        spinSound.loop = !!CONFIG.AUDIO.SPIN_LOOP;
			                        spinSound.playbackRate = curRate;
			                        spinSound.play().catch(() => {});
			                    } catch (_) {}
			                }

			                const raf = () => {
			                    if (token !== STATE.spinToken) {
			                        stopSpinDriver(true);
			                        return;
			                    }

			                    const now = performance.now();
			                    const p = clamp((now - t0) / durationMs, 0, 1);

			                    // steady-rate updates (no flutter)
			                    if (spinSound && (now - lastUpdate) >= UPDATE_MS) {
			                        lastUpdate = now;

			                        const d = _mt2EaseDeriv(p);
			                        const speed = (absDelta * d) / Math.max(1, durationMs); // deg/ms
			                        const speedNorm = clamp(speed / SPEED_REF, 0, 1);

			                        const targetRate = RATE_MIN + (RATE_MAX - RATE_MIN) * speedNorm;
			                        curRate = curRate + (targetRate - curRate) * SMOOTH;

			                        try {
			                            spinSound.playbackRate = clamp(curRate, 0.7, 1.6);
			                        } catch (_) {}

			                        let vol = baseSpinVol;
			                        if (now >= tFade) {
			                            const k = 1 - clamp((now - tFade) / Math.max(180, (tEnd - tFade)), 0, 1);
			                            vol = baseSpinVol * Math.max(0, k);
			                        }
			                        try {
			                            spinSound.volume = clamp(vol, 0, 1);
			                        } catch (_) {}
			                    }

			                    if (p >= 1 || now >= tEnd + 22) {
			                        stopSpinDriver(true);
			                        return;
			                    }

			                    STATE.spinAudioRaf = requestAnimationFrame(raf);
			                };

			                STATE.spinAudioRaf = requestAnimationFrame(raf);
			            }

			            // =========================
			            // FX Button (PREMIUM RIPPLE + POINTER SAFE + LOW-JANK)
			            // =========================
			            function _mt2EnsureBtnFxStyle() {
			                if (document.getElementById("mt2-btnfx-style")) return;
			                const st = document.createElement("style");
			                st.id = "mt2-btnfx-style";
			                st.textContent = `
						    .mt2-fxbtn{ position:relative; overflow:hidden; -webkit-tap-highlight-color:transparent; }
						    .mt2-fxbtn .mt2-ripple{
						      position:absolute; inset:0; pointer-events:none;
						      background: radial-gradient(circle at var(--fx-x,50%) var(--fx-y,50%),
						        rgba(255,255,255,.28) 0%,
						        rgba(34,197,94,.22) 22%,
						        rgba(255,255,255,.10) 42%,
						        rgba(0,0,0,0) 70%);
						      transform: scale(.92);
						      opacity:0;
						      filter: blur(.2px);
						    }
						    .mt2-fxbtn.mt2-fx .mt2-ripple{
						      animation: mt2Ripple .56s cubic-bezier(.2,.8,.2,1) both;
						    }
						    @keyframes mt2Ripple{
						      0%{ opacity:0; transform:scale(.86); }
						      12%{ opacity:1; }
						      100%{ opacity:0; transform:scale(1.28); }
						    }
						    .mt2-fxbtn.mt2-press{
						      transform: translateZ(0) scale(.985);
						      filter: saturate(1.05) brightness(1.06);
						      transition: transform .12s cubic-bezier(.2,.8,.2,1), filter .18s cubic-bezier(.2,.8,.2,1);
						    }
						  `;
			                document.head.appendChild(st);
			            }

			            function _mt2GetEventXY(ev, rect) {
			                if (!ev || !rect) return {
			                    x: rect.width / 2,
			                    y: rect.height / 2
			                };

			                // pointer/mouse
			                if (ev.clientX != null && ev.clientY != null) {
			                    return {
			                        x: ev.clientX - rect.left,
			                        y: ev.clientY - rect.top
			                    };
			                }
			                // touch
			                const t = (ev.touches && ev.touches[0]) || (ev.changedTouches && ev.changedTouches[0]);
			                if (t && t.clientX != null && t.clientY != null) {
			                    return {
			                        x: t.clientX - rect.left,
			                        y: t.clientY - rect.top
			                    };
			                }
			                return {
			                    x: rect.width / 2,
			                    y: rect.height / 2
			                };
			            }

			            function pressFX(btn, ev) {
			                if (!btn) return;

			                _mt2EnsureBtnFxStyle();
			                btn.classList.add("mt2-fxbtn");

			                // ensure ripple child once
			                let rp = btn.querySelector(".mt2-ripple");
			                if (!rp) {
			                    rp = document.createElement("span");
			                    rp.className = "mt2-ripple";
			                    btn.appendChild(rp);
			                }

			                const rect = btn.getBoundingClientRect();
			                const p = _mt2GetEventXY(ev, rect);
			                btn.style.setProperty("--fx-x", `${p.x}px`);
			                btn.style.setProperty("--fx-y", `${p.y}px`);

			                // restart animation (class toggle)
			                btn.classList.remove("mt2-fx");
			                void btn.offsetWidth;
			                btn.classList.add("mt2-fx");

			                // subtle press state
			                btn.classList.add("mt2-press");
			                clearTimeout(btn._mt2FxT);
			                btn._mt2FxT = setTimeout(() => {
			                    btn.classList.remove("mt2-fx");
			                    btn.classList.remove("mt2-press");
			                }, 560);

			                // haptic (safe + reduced motion aware)
			                try {
			                    if (navigator.vibrate && !isReducedMotion()) navigator.vibrate(12);
			                } catch (_) {}
			            }

			            // =========================
			            // Wheel rotation persist + apply (ULTRA STABLE + rAF + QUANTIZE)
			            // =========================
			            function _mt2SanitizeDeg(v) {
			                const n = Number(v);
			                if (!Number.isFinite(n)) return 0;
			                if (Math.abs(n) > 1e9) return ((n % 360) + 360) % 360;
			                return n;
			            }

			            function _mt2NormDeg(d) {
			                d = _mt2SanitizeDeg(d);
			                return ((d % 360) + 360) % 360;
			            }

			            function _mt2QuantizeDeg(deg, step = 0.001) {
			                const n = _mt2SanitizeDeg(deg);
			                const s = Math.max(1e-6, Number(step) || 0.001);
			                return Math.round(n / s) * s;
			            }

			            function applyWheelRotation(deg) {
			                const wheel = $("wheel");
			                if (!wheel) return;

			                // one-time GPU prep
			                if (wheel.dataset.mt2RotPrep !== "1") {
			                    wheel.dataset.mt2RotPrep = "1";
			                    wheel.style.transformOrigin = "50% 50%";
			                    wheel.style.backfaceVisibility = "hidden";
			                    wheel.style.transformStyle = "preserve-3d";
			                    wheel.style.willChange = "transform";
			                    wheel.style.contain = wheel.style.contain || "paint";
			                }

			                // NOTE:
			                // Jangan remove class 'spinning' di sini — itu bisa bunuh animasi spin kalau fungsi ini kepanggil saat spin.
			                // wheel.classList.remove("spinning");

			                // rAF apply (reduces layout-jank during rapid updates)
			                const target = _mt2SanitizeDeg(deg || 0);

			                // normalize compare supaya gak “miss” gara-gara float micro-diff
			                const targetQ = _mt2QuantizeDeg(target, 0.0005);

			                if (wheel._mt2RotTargetQ === targetQ && wheel._mt2RotAppliedQ === targetQ) return;
			                wheel._mt2RotTargetQ = targetQ;

			                if (wheel._mt2RotRaf) return;
			                wheel._mt2RotRaf = requestAnimationFrame(() => {
			                    wheel._mt2RotRaf = 0;

			                    const d = _mt2SanitizeDeg(wheel._mt2RotTargetQ || 0);
			                    const dQ = _mt2QuantizeDeg(d, 0.0005);
			                    if (wheel._mt2RotAppliedQ === dQ) return;
			                    wheel._mt2RotAppliedQ = dQ;

			                    // SELALU set var (biar CSS bisa handle transform/transition)
			                    wheel.style.setProperty("--mt2-rot", `${dQ}deg`);

			                    // HANYA set inline transform kalau tidak sedang animasi (biar tidak override spin animation)
			                    // Ini yang sering bikin patch/jitter pas wheel rotate.
			                    try {
			                        const cs = getComputedStyle(wheel);
			                        const animOn = cs && cs.animationName && cs.animationName !== "none";
			                        const spinning = wheel.classList.contains("spinning") || wheel.dataset.mt2Spinning === "1";
			                        if (!animOn && !spinning) {
			                            wheel.style.transform = `rotate(${dQ}deg) translateZ(0)`;
			                        }
			                    } catch (_) {}
			                });
			            }

			            function saveRotation(deg) {
			                const d = _mt2QuantizeDeg(deg || 0, 0.001);
			                STATE.currentRotation = d;
			                try {
			                    lsSet(LS.ROTATION, String(d));
			                } catch (_) {}
			            }

			            // =========================
			            // WHEEL BG (SVG PREMIUM — NO SEAM + NO WEIRD PATCH)
			            // + PRIZE TEXT AS SVG (ULTRA SHARP, NO BLUR)
			            // =========================
			            function _mt2EnsureWheelSvgStyle() {
			                if (document.getElementById("mt2-wheel-svg-style")) return;

			                const st = document.createElement("style");
			                st.id = "mt2-wheel-svg-style";
			                st.textContent = `
						#wheel{ position:relative; overflow:hidden; border-radius:50%; }
						#wheel svg.mt2-wheel-bg{
						  position:absolute; inset:0;
						  width:100%; height:100%;
						  border-radius:50%;
						  pointer-events:none;
						  z-index:0;
						  transform: translateZ(0);
						  backface-visibility:hidden;
						  contain: paint;
						}
						/* optional: kalau kamu masih punya .prize-text sisa versi lama */
						#wheel .prize-text{ display:none !important; }
						`;
			                document.head.appendChild(st);
			            }

			            function _mt2EnsureWheelSvgBg(wheel) {
			                let svg = wheel.querySelector("svg.mt2-wheel-bg");
			                if (!svg) {
			                    svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
			                    svg.classList.add("mt2-wheel-bg");
			                    svg.setAttribute("viewBox", "0 0 100 100");
			                    // jangan "none" biar gak stretch kalau container gak perfect square
			                    svg.setAttribute("preserveAspectRatio", "xMidYMid meet");
			                    svg.setAttribute("aria-hidden", "true");
			                    svg.setAttribute("focusable", "false");
			                    wheel.insertBefore(svg, wheel.firstChild);
			                }
			                return svg;
			            }

			            function _mt2SvgEl(tag, attrs) {
			                const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
			                if (attrs)
			                    for (const k in attrs) el.setAttribute(k, String(attrs[k]));
			                return el;
			            }

			            function _mt2Polar(cx, cy, r, deg) {
			                const a = ((deg - 90) * Math.PI) / 180;
			                return {
			                    x: cx + r * Math.cos(a),
			                    y: cy + r * Math.sin(a)
			                };
			            }

			            function _mt2WedgePath(cx, cy, r, a0, a1) {
			                const p0 = _mt2Polar(cx, cy, r, a0);
			                const p1 = _mt2Polar(cx, cy, r, a1);
			                const da = (((a1 - a0) % 360) + 360) % 360;
			                const large = da > 180 ? 1 : 0;
			                return `M ${cx} ${cy} L ${p0.x.toFixed(4)} ${p0.y.toFixed(4)} A ${r} ${r} 0 ${large} 1 ${p1.x.toFixed(4)} ${p1.y.toFixed(4)} Z`;
			            }

			            function _mt2Hash(str) {
			                str = String(str || "");
			                let h = 2166136261;
			                for (let i = 0; i < str.length; i++) {
			                    h ^= str.charCodeAt(i);
			                    h = Math.imul(h, 16777619);
			                }
			                return (h >>> 0).toString(36);
			            }

			            function _mt2WheelThemeFromCSS(wheel) {
			                // Solid slice colors (biar ga ada "patchy" beda warna per segmen)
			                const out = {
			                    segGreen: "#064e3b",
			                    segLight: "#f1f5f9",
			                    textDark: "#05281d",
			                    textLight: "#ffffff",
			                };
			                try {
			                    const cs = getComputedStyle(wheel);
			                    const v = (k) => (cs.getPropertyValue(k) || "").trim();
			                    const g = v("--wheel-seg-green");
			                    const l = v("--wheel-seg-light");
			                    const td = v("--wheel-text-dark");
			                    const tl = v("--wheel-text-light");
			                    if (g) out.segGreen = g;
			                    if (l) out.segLight = l;
			                    if (td) out.textDark = td;
			                    if (tl) out.textLight = tl;
			                } catch (_) {}
			                return out;
			            }

			            function _mt2BuildWheelSvgBgMarkup({
			                n,
			                startOffsetDeg,
			                allowNoise,
			                theme,
			                uidSeed
			            }) {
			                const seg = 360 / Math.max(1, n);

			                // Overlap cukup untuk bunuh seam (tanpa “makan” tetangga)
			                const overlap = Math.max(0.20, Math.min(0.44, 0.32 * (8 / Math.max(8, n))));
			                const halfOv = overlap * 0.5;

			                const cx = 50,
			                    cy = 50,
			                    r = 49.6;
			                const off = _mt2NormDeg(startOffsetDeg || 0);

			                const uid = String(uidSeed || "mt2").slice(0, 10);
			                const idClip = `mt2_clip_${uid}`;
			                const idLight = `mt2_light_${uid}`;
			                const idGlow = `mt2_glow_${uid}`;
			                const idV = `mt2_v_${uid}`;
			                const idNoise = `mt2_noise_${uid}`;

			                // slices
			                let wedges = "";
			                for (let i = 0; i < n; i++) {
			                    const a0 = i * seg - halfOv;
			                    const a1 = (i + 1) * seg + halfOv;
			                    const fill = i % 2 === 0 ? theme.segGreen : theme.segLight;
			                    wedges += `<path d="${_mt2WedgePath(cx, cy, r, a0, a1)}" fill="${fill}" shape-rendering="geometricPrecision"/>`;
			                }

			                // separators (emboss super halus) -> bikin “casino” tanpa seam aneh
			                let seps = "";
			                const rOuter = 49.15;
			                const rInner = 14.2;
			                for (let i = 0; i < n; i++) {
			                    const ang = i * seg;
			                    const pO = _mt2Polar(cx, cy, rOuter, ang);
			                    const pI = _mt2Polar(cx, cy, rInner, ang);
			                    const x1 = pI.x.toFixed(4),
			                        y1 = pI.y.toFixed(4);
			                    const x2 = pO.x.toFixed(4),
			                        y2 = pO.y.toFixed(4);

			                    // dark line
			                    seps += `<path d="M ${x1} ${y1} L ${x2} ${y2}" stroke="rgba(0,0,0,0.12)" stroke-width="0.16" stroke-linecap="round" shape-rendering="geometricPrecision"/>`;
			                    // light edge (very subtle)
			                    seps += `<path d="M ${x1} ${y1} L ${x2} ${y2}" stroke="rgba(255,255,255,0.05)" stroke-width="0.10" stroke-linecap="round" shape-rendering="geometricPrecision"/>`;
			                }

			                const defs = `
						<defs>
						  <clipPath id="${idClip}">
						    <circle cx="50" cy="50" r="49.35"/>
						  </clipPath>

						  <!-- soft directional light (SUPER halus, rata; tidak bikin patch) -->
						  <radialGradient id="${idLight}" cx="50%" cy="30%" r="78%">
						    <stop offset="0%" stop-color="rgba(255,255,255,0.11)"/>
						    <stop offset="48%" stop-color="rgba(255,255,255,0.045)"/>
						    <stop offset="100%" stop-color="rgba(255,255,255,0)"/>
						  </radialGradient>

						  <!-- edge glow (seragam di pinggir -> ga bikin patch) -->
						  <radialGradient id="${idGlow}" cx="50%" cy="50%" r="62%">
						    <stop offset="68%" stop-color="rgba(255,255,255,0)"/>
						    <stop offset="88%" stop-color="rgba(255,255,255,0.10)"/>
						    <stop offset="100%" stop-color="rgba(0,0,0,0.18)"/>
						  </radialGradient>

						  <!-- vignette untuk depth -->
						  <radialGradient id="${idV}" cx="50%" cy="50%" r="62%">
						    <stop offset="0%" stop-color="rgba(0,0,0,0)"/>
						    <stop offset="74%" stop-color="rgba(0,0,0,0.07)"/>
						    <stop offset="100%" stop-color="rgba(0,0,0,0.23)"/>
						  </radialGradient>

						  ${
						    allowNoise
						      ? `
						  <filter id="${idNoise}" x="-20%" y="-20%" width="140%" height="140%">
						    <feTurbulence type="fractalNoise" baseFrequency="0.85" numOctaves="2" stitchTiles="stitch" />
						    <feColorMatrix type="matrix"
						      values="0 0 0 0 0
						              0 0 0 0 0
						              0 0 0 0 0
						              0 0 0 .10 0" />
						  </filter>`
						      : ``
						  }
						</defs>
						`;

			                // overlays (SEMUA di-clip -> no spill/no patch)
			                const overlays = `
						<g clip-path="url(#${idClip})">
						  <circle cx="50" cy="50" r="49.2" fill="url(#${idLight})" opacity="0.98"/>
						  <circle cx="50" cy="50" r="49.2" fill="url(#${idGlow})" opacity="0.95"/>
						  <circle cx="50" cy="50" r="49.2" fill="url(#${idV})"/>
						  ${allowNoise ? `<circle cx="50" cy="50" r="49.2" filter="url(#${idNoise})" opacity="0.60"/>` : ``}
						</g>
						`;

			                return `
						${defs}
						<g id="mt2-slices" transform="rotate(${off} 50 50)">
						  ${wedges}
						  <g id="mt2-seps">${seps}</g>
						</g>
						<g id="mt2-overlays">${overlays}</g>
						<g id="mt2-labels"></g>
						`;
			            }

			            function setWheelBackground() {
			                const wheel = $("wheel");
			                if (!wheel) return;

			                _mt2EnsureWheelSvgStyle();

			                // matikan background lama (conic-gradient) supaya gak double lighting
			                try {
			                    wheel.style.background = "none";
			                    wheel.style.backgroundImage = "none";
			                    wheel.style.setProperty("--wheel-bg", "none");
			                } catch (_) {}

			                const n = PRIZES.length || 1;
			                const off = _mt2NormDeg(CONFIG.WHEEL.START_OFFSET_DEG || 0);
			                const theme = _mt2WheelThemeFromCSS(wheel);

			                // low-end smart
			                const devMem = Number(navigator.deviceMemory || 0) || 4;
			                const cores = Number(navigator.hardwareConcurrency || 0) || 6;
			                const saveData = !!(navigator.connection && navigator.connection.saveData);
			                const lowEnd = saveData || devMem <= 2 || cores <= 4;
			                const allowNoise = !lowEnd && !isReducedMotion();

			                const svg = _mt2EnsureWheelSvgBg(wheel);

			                const key = `${n}|${off.toFixed(3)}|${allowNoise ? 1 : 0}|${theme.segGreen}|${theme.segLight}`;
			                if (svg.dataset.mt2Key !== key) {
			                    svg.dataset.mt2Key = key;
			                    const uidSeed = _mt2Hash(key);
			                    svg.innerHTML = _mt2BuildWheelSvgBgMarkup({
			                        n,
			                        startOffsetDeg: off,
			                        allowNoise,
			                        theme,
			                        uidSeed
			                    });
			                } else {
			                    if (!svg.querySelector("#mt2-labels")) {
			                        const g = _mt2SvgEl("g", {
			                            id: "mt2-labels"
			                        });
			                        svg.appendChild(g);
			                    }
			                }
			            }

			            function _mt2GetMeasureCtxWheel() {
			                try {
			                    const wheel = $("wheel");
			                    if (wheel && wheel._mt2MeasureCtx) return wheel._mt2MeasureCtx;
			                    const c = document.createElement("canvas");
			                    c.width = 64;
			                    c.height = 64;
			                    const ctx = c.getContext("2d");
			                    if (wheel) wheel._mt2MeasureCtx = ctx || null;
			                    return ctx || null;
			                } catch (_) {
			                    return null;
			                }
			            }

			            function _mt2FitFontSize(ctx, text, maxWidth, basePx, minPx, weight, family) {
			                const t = String(text || "");
			                if (!ctx || !t) return Math.max(minPx, basePx);

			                let lo = Math.max(8, minPx | 0);
			                let hi = Math.max(lo, basePx | 0);
			                let best = lo;

			                while (lo <= hi) {
			                    const mid = (lo + hi) >> 1;
			                    ctx.font = `${weight} ${mid}px ${family}`;
			                    const w = ctx.measureText(t).width;
			                    if (w <= maxWidth) {
			                        best = mid;
			                        lo = mid + 1;
			                    } else hi = mid - 1;
			                }
			                return best;
			            }

			            function drawWheelPrizes() {
			                const wheel = $("wheel");
			                if (!wheel) return;

			                // bersihin div text versi lama biar gak numpuk
			                try {
			                    wheel.querySelectorAll(".prize-text").forEach((el) => el.remove());
			                } catch (_) {}

			                setWheelBackground();

			                const svg = wheel.querySelector("svg.mt2-wheel-bg");
			                if (!svg) return;

			                const labels = svg.querySelector("#mt2-labels");
			                if (!labels) return;

			                while (labels.firstChild) labels.removeChild(labels.firstChild);

			                const n = PRIZES.length || 1;
			                const seg = 360 / n;
			                const off = _mt2NormDeg(CONFIG.WHEEL.START_OFFSET_DEG || 0);

			                const size = Math.min(wheel.clientWidth || 0, wheel.clientHeight || 0);
			                if (!size) return;

			                const theme = _mt2WheelThemeFromCSS(wheel);

			                const pxPerUnit = size / 100;
			                const unitPerPx = 1 / Math.max(0.0001, pxPerUnit);

			                const BASE_RADIUS_PX = Math.round(size * 0.345);
			                const BONUS_FACTOR = 0.94;
			                const LONG_FACTOR = 0.94;

			                const arcLen = Math.PI * 2 * BASE_RADIUS_PX * (seg / 360);
			                const maxTextW = Math.max(72, Math.min(arcLen * 0.9, size * 0.44));

			                const ctx = _mt2GetMeasureCtxWheel();
			                const family = "system-ui, -apple-system, Segoe UI, Roboto, Arial";
			                const weight = 900; // lebih aman daripada 1000 (menghindari fallback “pecah”)
			                const baseFontPx = Math.max(12, Math.min(20, Math.round(size * 0.034)));

			                for (let i = 0; i < n; i++) {
			                    const prize = String(PRIZES[i] ?? "");
			                    const angle = i * seg + seg / 2 + off;

			                    const a360 = ((angle % 360) + 360) % 360;
			                    const flip = a360 > 90 && a360 < 270;
			                    const flipDeg = flip ? 180 : 0;

			                    let rPx = BASE_RADIUS_PX;
			                    let fsPx = baseFontPx;

			                    if (/bonus/i.test(prize)) {
			                        rPx = Math.round(rPx * BONUS_FACTOR);
			                        fsPx = Math.max(12, Math.min(17, fsPx));
			                    }
			                    if (prize.length >= 5) rPx = Math.round(rPx * LONG_FACTOR);

			                    const fittedPx = _mt2FitFontSize(ctx, prize, maxTextW, fsPx, 12, weight, family);
			                    const fontU = (fittedPx * unitPerPx).toFixed(3);
			                    const rU = (rPx * unitPerPx).toFixed(3);

			                    const isLightSlice = i % 2 === 1;
			                    const fill = isLightSlice ? theme.textDark : theme.textLight;

			                    const strokePx = isLightSlice ? 0.55 : 0.7;
			                    const strokeU = (strokePx * unitPerPx).toFixed(3);
			                    const stroke = isLightSlice ? "rgba(0,0,0,0.22)" : "rgba(0,0,0,0.34)";

			                    const g = _mt2SvgEl("g", {
			                        transform: `translate(50 50) rotate(${angle.toFixed(6)}) translate(0 -${rU}) rotate(90) rotate(${flipDeg})`,
			                    });

			                    const t = _mt2SvgEl("text", {
			                        x: "0",
			                        y: "0",
			                        "text-anchor": "middle",
			                        "dominant-baseline": "middle",
			                        "alignment-baseline": "central",
			                        "font-family": family,
			                        "font-weight": String(weight),
			                        "font-size": fontU,
			                        "letter-spacing": "0.07em",
			                        fill: fill,
			                        stroke: stroke,
			                        "stroke-width": strokeU,
			                        "paint-order": "stroke fill",
			                        "stroke-linejoin": "round",
			                        "shape-rendering": "geometricPrecision",
			                        "text-rendering": "geometricPrecision",
			                    });

			                    t.textContent = prize;

			                    g.appendChild(t);
			                    labels.appendChild(g);
			                }
			            }

			            // =========================
			            // Auto Resize (RAF + Font-ready + Orientation safe)
			            // =========================
			            function initWheelAutoResize() {
			                const wrap = $("wheelWrap");
			                if (!wrap) return;

			                if (wrap._mt2WheelResizeBound) return;
			                wrap._mt2WheelResizeBound = true;

			                let raf = 0;
			                const rerender = () => {
			                    if (raf) cancelAnimationFrame(raf);
			                    raf = requestAnimationFrame(() => {
			                        raf = 0;
			                        drawWheelPrizes();
			                    });
			                };

			                if (window.ResizeObserver) {
			                    const ro = new ResizeObserver(() => rerender());
			                    ro.observe(wrap);
			                    wrap._mt2WheelRO = ro;
			                } else {
			                    window.addEventListener("resize", rerender, {
			                        passive: true
			                    });
			                    window.addEventListener("orientationchange", () => {
			                        rerender();
			                        setTimeout(rerender, 240);
			                    }, {
			                        passive: true
			                    });
			                }

			                try {
			                    if (document.fonts && document.fonts.ready) {
			                        document.fonts.ready.then(rerender).catch(() => {});
			                    }
			                } catch (_) {}

			                rerender();
			            }

			            // =========================
			            // FX Canvas (PREMIUM + GRAD CACHE + LOW-END SMART + DESYNC)
			            // =========================
			            function initFxParticlesCanvas() {
			                const c = $("fxCanvas");
			                if (!c) return;

			                c.style.pointerEvents = "none";

			                const ctx = c.getContext("2d", {
			                    alpha: true,
			                    desynchronized: true
			                });
			                if (!ctx) return;

			                if (isReducedMotion()) {
			                    c.style.display = "none";
			                    return;
			                }

			                const devMem = Number(navigator.deviceMemory || 0) || 4;
			                const cores = Number(navigator.hardwareConcurrency || 0) || 6;
			                const saveData = !!(navigator.connection && navigator.connection.saveData);
			                const lowEnd = saveData || devMem <= 2 || cores <= 4;

			                try {
			                    document.body.classList.toggle("low-end", !!lowEnd);
			                } catch (_) {}

			                let w = 0,
			                    h = 0,
			                    dpr = 1;
			                const parts = [];
			                const maxParts = lowEnd ? 42 : 88;

			                let rafId = 0;
			                let running = true;
			                let bgGrad = null;

			                const resize = () => {
			                    const dprCap = lowEnd ? 1.35 : 2;
			                    dpr = Math.min(dprCap, window.devicePixelRatio || 1);
			                    w = Math.max(1, Math.floor(window.innerWidth));
			                    h = Math.max(1, Math.floor(window.innerHeight));

			                    c.width = Math.floor(w * dpr);
			                    c.height = Math.floor(h * dpr);
			                    c.style.width = w + "px";
			                    c.style.height = h + "px";

			                    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

			                    try {
			                        const r = Math.max(w, h) * 0.55;
			                        bgGrad = ctx.createRadialGradient(w * 0.5, h * 0.28, 0, w * 0.5, h * 0.28, r);
			                        bgGrad.addColorStop(0, "rgba(34,197,94,0.075)");
			                        bgGrad.addColorStop(1, "rgba(0,0,0,0)");
			                    } catch (_) {
			                        bgGrad = null;
			                    }
			                };

			                const rand = (a, b) => a + Math.random() * (b - a);
			                const pick = (arr) => arr[(Math.random() * arr.length) | 0];

			                const spawn = () => {
			                    parts.push({
			                        x: rand(-40, w + 40),
			                        y: rand(-40, h + 40),
			                        r: rand(0.85, lowEnd ? 2.0 : 2.6),
			                        vy: rand(-0.13, -0.04),
			                        vx: rand(-0.06, 0.06),
			                        a: rand(0.14, lowEnd ? 0.4 : 0.56),
			                        tw: rand(0.004, 0.01),
			                        ph: rand(0, Math.PI * 2),
			                        hue: pick([120, 140, 45, 50, 160]),
			                        life: rand(2400, 5200),
			                        t: 0,
			                    });
			                };

			                const ensure = () => {
			                    while (parts.length < maxParts) spawn();
			                };

			                const draw = (dt) => {
			                    ctx.clearRect(0, 0, w, h);

			                    if (bgGrad) {
			                        ctx.fillStyle = bgGrad;
			                        ctx.fillRect(0, 0, w, h);
			                    }

			                    for (let i = parts.length - 1; i >= 0; i--) {
			                        const p = parts[i];
			                        p.t += dt;
			                        p.x += p.vx * dt;
			                        p.y += p.vy * dt;

			                        const tw = Math.sin(p.ph + p.t * p.tw) * 0.5 + 0.5;
			                        const alpha = Math.max(0, Math.min(1, p.a * (0.55 + tw * 0.65) * (1 - p.t / p.life)));
			                        const rr = p.r * (0.85 + tw * 0.65);

			                        ctx.beginPath();
			                        ctx.fillStyle = `hsla(${p.hue}, 80%, 70%, ${alpha})`;
			                        ctx.arc(p.x, p.y, rr, 0, Math.PI * 2);
			                        ctx.fill();

			                        if (!lowEnd) {
			                            ctx.strokeStyle = `hsla(${p.hue}, 85%, 78%, ${alpha * 0.28})`;
			                            ctx.lineWidth = 1;
			                            ctx.beginPath();
			                            ctx.moveTo(p.x - rr * 2.2, p.y);
			                            ctx.lineTo(p.x + rr * 2.2, p.y);
			                            ctx.moveTo(p.x, p.y - rr * 2.2);
			                            ctx.lineTo(p.x, p.y + rr * 2.2);
			                            ctx.stroke();
			                        }

			                        if (p.t >= p.life || p.y < -80) {
			                            parts.splice(i, 1);
			                            spawn();
			                        }
			                    }
			                };

			                let last = performance.now();
			                const tick = () => {
			                    if (!running) return;

			                    const now = performance.now();
			                    const dtRaw = now - last;
			                    const dt = Math.min(34, dtRaw);
			                    last = now;

			                    if (dtRaw > 140 && parts.length > maxParts * 0.75) parts.length = Math.floor(maxParts * 0.65);

			                    ensure();
			                    draw(dt);

			                    rafId = requestAnimationFrame(tick);
			                };

			                const stop = () => {
			                    running = false;
			                    if (rafId) cancelAnimationFrame(rafId);
			                    rafId = 0;
			                };
			                const start = () => {
			                    if (running) return;
			                    running = true;
			                    last = performance.now();
			                    rafId = requestAnimationFrame(tick);
			                };

			                resize();
			                window.addEventListener("resize", resize, {
			                    passive: true
			                });

			                document.addEventListener("visibilitychange", () => {
			                    if (document.hidden) stop();
			                    else start();
			                });

			                rafId = requestAnimationFrame(tick);
			            }

			            // =========================
			            // HISTORY (unique + live) — ULTRA MODERN + SMART + SMOOTH
			            // =========================
			            function ensureHistoryStylesOnce() {
			                if (document.getElementById("mt2-history-style")) return;
			                const st = document.createElement("style");
			                st.id = "mt2-history-style";
			                st.textContent = `
			  /* winners table polish (safe, minimal-invasive) */
			  #winnersTable{ position: relative; }
			  #winnersTable .winners-table-header{
			    position: sticky;
			    top: 0;
			    z-index: 6;
			    backdrop-filter: blur(8px);
			    -webkit-backdrop-filter: blur(8px);
			  }
			  #winnersTable .winners-jump{
			    position:absolute;
			    right:10px;
			    top:50%;
			    transform: translateY(-50%);
			    border: 1px solid rgba(34,197,94,.38);
			    background: linear-gradient(180deg, rgba(34,197,94,.22), rgba(34,197,94,.10));
			    color: rgba(255,255,255,.92);
			    border-radius: 999px;
			    padding: 6px 10px;
			    font-weight: 1000;
			    letter-spacing: .35px;
			    cursor: pointer;
			    box-shadow: 0 18px 34px rgba(0,0,0,.35);
			    transition: transform .12s ease, filter .12s ease, opacity .12s ease;
			  }
			  #winnersTable .winners-jump:hover{ filter: brightness(1.06); }
			  #winnersTable .winners-jump:active{ transform: translateY(-50%) translateY(1px); }

			  #winnersTable .winners-table-row{
			    will-change: transform, background;
			    transition: transform 260ms cubic-bezier(.18,.82,.18,1), background 240ms ease;
			  }

			  #winnersTable .winners-table-row.is-new{
			    background: linear-gradient(90deg, rgba(34,197,94,.16), rgba(255,255,255,0) 60%);
			  }
			  #winnersTable .winners-table-row.is-user{
			    background: linear-gradient(90deg, rgba(243,178,74,.14), rgba(255,255,255,0) 62%);
			  }

			  #winnersTable .winner-idline{
			    display:flex;
			    align-items:center;
			    gap:8px;
			    min-width:0;
			  }
			  #winnersTable .winner-badge{
			    flex:0 0 auto;
			    font-size: 10px;
			    font-weight: 1000;
			    letter-spacing: .5px;
			    padding: 2px 8px;
			    border-radius: 999px;
			    border: 1px solid rgba(255,255,255,.12);
			    background: rgba(0,0,0,.18);
			    opacity: .9;
			    user-select:none;
			  }
			  #winnersTable .winner-badge.badge-new{
			    border-color: rgba(34,197,94,.35);
			    background: rgba(34,197,94,.12);
			  }
			  #winnersTable .winner-badge.badge-you{
			    border-color: rgba(243,178,74,.35);
			    background: rgba(243,178,74,.12);
			  }
			  #winnersTable .winner-meta{
			    opacity: .72;
			    font-size: 12px;
			    line-height: 1.25;
			  }

			  @media (prefers-reduced-motion: reduce){
			    #winnersTable .winners-table-row{ transition:none !important; }
			  }
			  `;
			                document.head.appendChild(st);
			            }

			            // ---------- weighted prize (lebih fleksibel + aman)
			            function pickWeightedPrizeKey() {
			                // optional: kalau suatu saat kamu mau override dari CONFIG.HISTORY.WEIGHT_BAG
			                const bag = (CONFIG.HISTORY && CONFIG.HISTORY.WEIGHT_BAG) || [
			                    ["BONUS 10%", 30],
			                    ["25K", 17],
			                    ["50K", 18],
			                    ["75K", 14],
			                    ["100K", 12],
			                    ["200K", 9],
			                ];
			                const total = bag.reduce((a, [, w]) => a + (Number(w) || 0), 0) || 1;
			                let r = Math.random() * total;
			                for (const [p, w] of bag) {
			                    r -= (Number(w) || 0);
			                    if (r <= 0) return p;
			                }
			                return "50K";
			            }

			            function _mt2RandChar() {
			                const s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
			                return s[(Math.random() * s.length) | 0];
			            }

			            function randomUserId() {
			                const len = randInt(7, 11);
			                let out = "";
			                // crypto random if available (lebih stabil)
			                try {
			                    if (window.crypto && crypto.getRandomValues) {
			                        const buf = new Uint8Array(len);
			                        crypto.getRandomValues(buf);
			                        const s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
			                        for (let i = 0; i < len; i++) out += s[buf[i] % s.length];
			                        if (Math.random() < 0.35) out += String(randInt(0, 9));
			                        return out;
			                    }
			                } catch (_) {}
			                for (let i = 0; i < len; i++) out += _mt2RandChar();
			                if (Math.random() < 0.35) out += String(randInt(0, 9));
			                return out;
			            }

			            function maskUserId(str) {
			                const s = String(str || "");
			                if (s.length <= 6) return s.slice(0, 2) + "****";
			                return s.slice(0, 3) + "****" + s.slice(-2);
			            }

			            function makeEntryId(prefix) {
			                const p = String(prefix || "w");
			                try {
			                    if (window.crypto && crypto.getRandomValues) {
			                        const b = new Uint32Array(3);
			                        crypto.getRandomValues(b);
			                        return `${p}-${Date.now()}-${b[0].toString(16)}${b[1].toString(16)}${b[2].toString(16)}`;
			                    }
			                } catch (_) {}
			                return `${p}-${Date.now()}-${Math.random().toString(16).slice(2)}-${Math.random().toString(16).slice(2)}`;
			            }

			            function rememberMasked(masked) {
			                const v = String(masked || "");
			                if (!v || STATE.recentMasked.has(v)) return;
			                STATE.recentMasked.add(v);
			                STATE.recentMaskedQueue.push(v);
			                while (STATE.recentMaskedQueue.length > CONFIG.HISTORY.UNIQUE_MASK_KEEP) {
			                    const old = STATE.recentMaskedQueue.shift();
			                    STATE.recentMasked.delete(old);
			                }
			            }

			            function uniqueMaskedId(maxTry = 70) {
			                for (let i = 0; i < maxTry; i++) {
			                    const masked = maskUserId(randomUserId());
			                    if (!STATE.recentMasked.has(masked)) {
			                        rememberMasked(masked);
			                        return masked;
			                    }
			                }
			                const fallback = maskUserId(randomUserId());
			                rememberMasked(fallback);
			                return fallback;
			            }

			            function generateMockWinnersRandom() {
			                let base = Date.now() - randInt(40, 220) * 1000;
			                const arr = [];
			                for (let i = 0; i < CONFIG.HISTORY.SEED_COUNT; i++) {
			                    const prizeKey = pickWeightedPrizeKey();
			                    const masked = uniqueMaskedId();

			                    arr.push({
			                        id: makeEntryId("seed"),
			                        isUser: false,
			                        fullId: "",
			                        displayId: masked,
			                        prizeKey,
			                        prize: CONFIG.PRIZE_DISPLAY_MAP[prizeKey] || prizeKey,
			                        ts: base,
			                        isNew: false,
			                    });

			                    base -= randInt(18, 160) * 1000;
			                }
			                arr.sort((a, b) => (b.ts || 0) - (a.ts || 0));
			                return arr;
			            }

			            // ---------- time label (lebih rapi + cache + hemat)
			            const _mt2DTF = new Intl.DateTimeFormat("id-ID", {
			                day: "2-digit",
			                month: "short",
			                year: "numeric"
			            });
			            const _mt2Time2 = (d) => `${pad2(d.getHours())}:${pad2(d.getMinutes())}:${pad2(d.getSeconds())}`;
			            const _mt2RelCache = new Map(); // key => label

			            function timeLabel(ts) {
			                const t = Number(ts || Date.now());
			                const now = Date.now();
			                const diff = Math.max(0, now - t);

			                // cache per 10 detik bucket
			                const bucket = Math.floor(t / 10000);
			                const key = bucket + "|" + Math.floor(now / 10000);
			                const cached = _mt2RelCache.get(key);
			                if (cached && cached.t === t) return cached.v;

			                const d = new Date(t);
			                const dateStr = _mt2DTF.format(d);
			                const timeStr = _mt2Time2(d);

			                const sec = Math.floor(diff / 1000);
			                let rel = "baru saja";
			                if (sec >= 60) {
			                    const min = Math.floor(sec / 60);
			                    if (min < 60) rel = `${min}m lalu`;
			                    else {
			                        const hr = Math.floor(min / 60);
			                        if (hr < 24) rel = `${hr}j lalu`;
			                        else rel = `${Math.floor(hr / 24)} hari lalu`;
			                    }
			                }

			                const out = `${dateStr} ${timeStr} • ${rel}`;
			                _mt2RelCache.set(key, {
			                    t,
			                    v: out
			                });
			                if (_mt2RelCache.size > 220) _mt2RelCache.clear();
			                return out;
			            }

			            // ---------- meta ticker (no querySelectorAll spam)
			            function startMetaTickerOnce() {
			                if (STATE.metaTickerStarted) return;
			                STATE.metaTickerStarted = true;

			                if (!STATE._metaNodes) STATE._metaNodes = new Set();

			                const tick = () => {
			                    try {
			                        const table = $("winnersTable");
			                        const hasTable = !!table;
			                        const top = hasTable ? (table.scrollTop || 0) : 0;
			                        const vh = hasTable ? (table.clientHeight || 0) : 0;

			                        for (const el of STATE._metaNodes) {
			                            if (!el || !el.isConnected) {
			                                STATE._metaNodes.delete(el);
			                                continue;
			                            }

			                            // update only visible-ish
			                            if (hasTable) {
			                                const row = el.closest ? el.closest(".winners-table-row") : null;
			                                if (row && row.offsetTop != null) {
			                                    const y = row.offsetTop;
			                                    if (y + 64 < top || y - 64 > top + vh) continue;
			                                }
			                            }

			                            const ts = Number(el.getAttribute("data-ts") || Date.now());
			                            el.textContent = timeLabel(ts);
			                        }
			                    } catch (_) {}

			                    STATE.metaTimer = setTimeout(tick, CONFIG.HISTORY.META_TICK_MS);
			                };

			                STATE.metaTimer = setTimeout(tick, CONFIG.HISTORY.META_TICK_MS);
			            }

			            // ---------- smart render scheduler
			            function _mt2ScheduleRenderWinners(opts) {
			                STATE._renderWinnersOpts = Object.assign({
			                    preserveScroll: true
			                }, opts || {});
			                if (STATE._renderWinnersRaf) return;
			                STATE._renderWinnersRaf = requestAnimationFrame(() => {
			                    STATE._renderWinnersRaf = 0;
			                    renderWinners(STATE._renderWinnersOpts);
			                });
			            }

			            // ---------- new indicator (header button)
			            function _mt2UpdateNewIndicator() {
			                const table = $("winnersTable");
			                if (!table) return;
			                const btn = table.querySelector(".winners-jump");
			                if (!btn) return;

			                const n = Number(STATE._pendingNewCount || 0) || 0;
			                btn.hidden = n <= 0;
			                if (!btn.hidden) btn.textContent = `BARU (${n})`;
			            }

			            function pushWinnerEntry(entry) {
			                if (!entry) return;

			                // basic sanitize
			                if (!entry.id) entry.id = makeEntryId(entry.isUser ? "user" : "live");
			                entry.ts = Number(entry.ts || Date.now()) || Date.now();
			                entry.displayId = String(entry.displayId || "");
			                entry.prizeKey = String(entry.prizeKey || "");
			                entry.prize = String(entry.prize || (CONFIG.PRIZE_DISPLAY_MAP[entry.prizeKey] || entry.prizeKey) || "");

			                // anti-dupe (same masked+prize within short window)
			                try {
			                    const sig = `${entry.displayId}|${entry.prizeKey}`;
			                    const now = Date.now();
			                    if (!STATE._recentSig) STATE._recentSig = new Map();
			                    const last = STATE._recentSig.get(sig) || 0;
			                    if (now - last < 6500) return;
			                    STATE._recentSig.set(sig, now);
			                    if (STATE._recentSig.size > 80) STATE._recentSig.clear();
			                } catch (_) {}

			                // sound only for truly new live/user entry
			                if (entry.isNew) playHistorySfx();

			                // clear previous isNew
			                for (const w of STATE.winners) w.isNew = false;

			                // insert at top
			                STATE.winners.unshift(entry);

			                // trim
			                if (STATE.winners.length > CONFIG.HISTORY.KEEP_MAX) STATE.winners.length = CONFIG.HISTORY.KEEP_MAX;

			                // smart: if user not at top, don't force scroll; show "BARU (n)"
			                const table = $("winnersTable");
			                let userNearTop = true;
			                try {
			                    userNearTop = !table || (table.scrollTop || 0) <= 10;
			                } catch (_) {}

			                if (!userNearTop && !entry.isUser) {
			                    STATE._pendingNewCount = (Number(STATE._pendingNewCount || 0) || 0) + 1;
			                    _mt2UpdateNewIndicator();
			                    // still render but preserve scroll (no jump)
			                    _mt2ScheduleRenderWinners({
			                        preserveScroll: true,
			                        flip: true
			                    });
			                    return;
			                }

			                // if near top, keep top & reset pending
			                STATE._pendingNewCount = 0;
			                _mt2UpdateNewIndicator();
			                _mt2ScheduleRenderWinners({
			                    preserveScroll: false,
			                    stickToTop: true,
			                    flip: true
			                });
			            }

			            function stopLiveHistory() {
			                if (STATE.liveTimer) clearTimeout(STATE.liveTimer);
			                STATE.liveTimer = 0;
			            }

			            function startLiveHistory() {
			                if (STATE.liveTimer) return;
			                if (STATE.pauseReasons.size > 0) return;

			                const table = $("winnersTable");

			                const schedule = () => {
			                    stopLiveHistory();

			                    // smarter timing: slightly human-ish
			                    let ms = randInt(CONFIG.HISTORY.LIVE_MIN_MS, CONFIG.HISTORY.LIVE_MAX_MS);

			                    // if user not at top / interacting => slow down
			                    try {
			                        if (table) {
			                            const sc = table.scrollTop || 0;
			                            if (sc > 10) ms = Math.round(ms * 1.45);
			                            if (STATE._historyHovering) ms = Math.round(ms * 1.35);
			                        }
			                    } catch (_) {}

			                    // if tab hidden => delay more (but stop should handle too)
			                    if (document.hidden) ms = Math.max(ms, 12000);

			                    STATE.liveTimer = setTimeout(() => {
			                        const ok = !document.hidden &&
			                            !isModalOpen() &&
			                            !STATE.isSpin &&
			                            STATE.pauseReasons.size === 0 &&
			                            !(STATE._historyHovering);

			                        if (ok) {
			                            const prizeKey = pickWeightedPrizeKey();
			                            pushWinnerEntry({
			                                id: makeEntryId("live"),
			                                isUser: false,
			                                fullId: "",
			                                displayId: uniqueMaskedId(),
			                                prizeKey,
			                                prize: CONFIG.PRIZE_DISPLAY_MAP[prizeKey] || prizeKey,
			                                ts: Date.now(),
			                                isNew: true,
			                            });
			                        }

			                        schedule();
			                    }, ms);
			                };

			                schedule();
			            }

			            // =========================
			            // WINNERS RENDER (optimized FLIP + fragment reorder)
			            // =========================
			            function ensureWinnersHeader(table) {
			                let header = table.querySelector(".winners-table-header");
			                if (!header) {
			                    header = document.createElement("div");
			                    header.className = "winners-table-header";
			                    header.innerHTML = "<div>NO</div><div>USER ID</div><div>HADIAH</div>";
			                    table.appendChild(header);
			                }

			                // attach jump button (smart new indicator)
			                if (!header.querySelector(".winners-jump")) {
			                    const btn = document.createElement("button");
			                    btn.type = "button";
			                    btn.className = "winners-jump";
			                    btn.hidden = true;
			                    btn.addEventListener("click", () => {
			                        const t = $("winnersTable");
			                        if (!t) return;
			                        try {
			                            t.scrollTo({
			                                top: 0,
			                                behavior: isReducedMotion() ? "auto" : "smooth"
			                            });
			                        } catch (_) {
			                            try {
			                                t.scrollTop = 0;
			                            } catch (_) {}
			                        }
			                        STATE._pendingNewCount = 0;
			                        _mt2UpdateNewIndicator();
			                    });
			                    header.style.position = header.style.position || "sticky";
			                    header.appendChild(btn);
			                }

			                return header;
			            }

			            function createRowEl(entry) {
			                const row = document.createElement("div");
			                row.className =
			                    "winners-table-row" + (entry.isNew ? " is-new" : "") + (entry.isUser ? " is-user" : "");
			                row.setAttribute("data-id", entry.id);
			                row.tabIndex = entry.isUser ? 0 : -1;

			                const c1 = document.createElement("div");
			                c1.className = "winner-no";

			                const c2 = document.createElement("div");
			                c2.className = "winner-id";

			                const badgeLine = document.createElement("div");
			                badgeLine.className = "winner-idline";

			                const badge = document.createElement("span");
			                badge.className = "winner-badge badge-new";
			                badge.textContent = "NEW";

			                const badgeYou = document.createElement("span");
			                badgeYou.className = "winner-badge badge-you";
			                badgeYou.textContent = "YOU";

			                // keep badges but toggle later
			                badge.hidden = true;
			                badgeYou.hidden = true;

			                const idText = document.createElement("span");
			                idText.className = "winner-idtext";
			                idText.textContent = "";

			                badgeLine.appendChild(badge);
			                badgeLine.appendChild(badgeYou);
			                badgeLine.appendChild(idText);

			                const meta = document.createElement("div");
			                meta.className = "winner-meta";
			                meta.setAttribute("data-ts", String(entry.ts || Date.now()));

			                const c2wrap = document.createElement("div");
			                c2wrap.appendChild(badgeLine);
			                c2wrap.appendChild(meta);

			                const c3 = document.createElement("div");
			                c3.className = "winner-prize";

			                row.append(c1, c2wrap, c3);
			                return row;
			            }

			            function patchRowContent(row, entry, index) {
			                row.classList.toggle("is-new", !!entry.isNew);
			                row.classList.toggle("is-user", !!entry.isUser);
			                row.tabIndex = entry.isUser ? 0 : -1;

			                const no = row.querySelector(".winner-no");
			                const idText = row.querySelector(".winner-idtext") || row.querySelector(".winner-id");
			                const meta = row.querySelector(".winner-meta");
			                const prize = row.querySelector(".winner-prize");

			                const bNew = row.querySelector(".badge-new");
			                const bYou = row.querySelector(".badge-you");
			                if (bNew) bNew.hidden = !entry.isNew;
			                if (bYou) bYou.hidden = !entry.isUser;

			                if (no) no.textContent = String(index + 1);
			                if (idText) idText.textContent = String(entry.displayId || "");
			                if (meta) {
			                    meta.setAttribute("data-ts", String(entry.ts || Date.now()));
			                    meta.textContent = timeLabel(entry.ts);
			                    if (!STATE._metaNodes) STATE._metaNodes = new Set();
			                    STATE._metaNodes.add(meta);
			                }
			                if (prize) prize.textContent = String(entry.prize || "");
			            }

			            function renderWinners(opts = {}) {
			                ensureHistoryStylesOnce();

			                const o = Object.assign({
			                    preserveScroll: true,
			                    stickToTop: false,
			                    flip: true
			                }, opts);
			                const table = $("winnersTable");
			                if (!table) return;

			                let prevScrollTop = 0;
			                try {
			                    prevScrollTop = table.scrollTop || 0;
			                } catch (_) {}

			                const header = ensureWinnersHeader(table);
			                _mt2UpdateNewIndicator();
			                startMetaTickerOnce();

			                // map current winners
			                STATE.winnersById = new Map();
			                for (const w of STATE.winners) STATE.winnersById.set(w.id, w);

			                const orderKey = STATE.winners.map((w) => w.id).join("|");
			                const shouldConsiderFlip = orderKey !== STATE.lastOrderKey;
			                STATE.lastOrderKey = orderKey;

			                const now = performance.now();
			                const scrollingRecently = now - STATE.lastScrollAt < CONFIG.HISTORY.FLIP_SCROLL_GUARD_MS;
			                const doFlip = !!o.flip && shouldConsiderFlip && !scrollingRecently && !isReducedMotion();

			                // FLIP: limit work to visible-ish rows only
			                const firstPos = {};
			                const top = table.scrollTop || 0;
			                const vh = table.clientHeight || 0;
			                const flipLimit = 18; // animate only first ~18 items (realistic + light)
			                if (doFlip) {
			                    for (let i = 0; i < Math.min(flipLimit, STATE.winners.length); i++) {
			                        const w = STATE.winners[i];
			                        const el = STATE.rowElById.get(w.id);
			                        if (el && el.isConnected) firstPos[w.id] = el.getBoundingClientRect().top;
			                    }
			                }

			                // ensure rows exist + patch
			                for (let i = 0; i < STATE.winners.length; i++) {
			                    const w = STATE.winners[i];
			                    if (!w.id) w.id = makeEntryId("w");
			                    let row = STATE.rowElById.get(w.id);
			                    if (!row || !row.isConnected) {
			                        row = createRowEl(w);
			                        STATE.rowElById.set(w.id, row);
			                    }
			                    patchRowContent(row, w, i);
			                }

			                // remove stale
			                for (const [id, el] of Array.from(STATE.rowElById.entries())) {
			                    if (!STATE.winnersById.has(id)) {
			                        try {
			                            el.remove();
			                        } catch (_) {}
			                        STATE.rowElById.delete(id);
			                    }
			                }

			                // reorder using fragment (minimal reflow)
			                const frag = document.createDocumentFragment();
			                if (header && header.isConnected) frag.appendChild(header);
			                for (const w of STATE.winners) {
			                    const row = STATE.rowElById.get(w.id);
			                    if (row) frag.appendChild(row);
			                }

			                // replace children (preserve scroll later)
			                try {
			                    table.replaceChildren(frag);
			                } catch (_) {
			                    // fallback
			                    table.innerHTML = "";
			                    table.appendChild(frag);
			                }

			                // FLIP apply
			                if (doFlip) {
			                    const lastPos = {};
			                    for (let i = 0; i < Math.min(flipLimit, STATE.winners.length); i++) {
			                        const w = STATE.winners[i];
			                        const el = STATE.rowElById.get(w.id);
			                        if (el && el.isConnected) lastPos[w.id] = el.getBoundingClientRect().top;
			                    }

			                    requestAnimationFrame(() => {
			                        for (let i = 0; i < Math.min(flipLimit, STATE.winners.length); i++) {
			                            const w = STATE.winners[i];
			                            const el = STATE.rowElById.get(w.id);
			                            if (!el || !el.isConnected) continue;
			                            const a = firstPos[w.id];
			                            const b = lastPos[w.id];
			                            if (typeof a !== "number" || typeof b !== "number") continue;
			                            const dy = a - b;
			                            if (Math.abs(dy) < 0.5) continue;

			                            el.style.transform = `translateY(${dy}px)`;
			                            el.style.transition = "transform 0ms";
			                        }
			                        requestAnimationFrame(() => {
			                            for (let i = 0; i < Math.min(flipLimit, STATE.winners.length); i++) {
			                                const w = STATE.winners[i];
			                                const el = STATE.rowElById.get(w.id);
			                                if (!el || !el.isConnected) continue;
			                                el.style.transition = "";
			                                el.style.transform = "";
			                            }
			                        });
			                    });
			                }

			                // scroll behavior
			                if (o.stickToTop) {
			                    try {
			                        table.scrollTop = 0;
			                    } catch (_) {}
			                } else if (o.preserveScroll) {
			                    // keep position if user reading older entries
			                    try {
			                        table.scrollTop = prevScrollTop;
			                    } catch (_) {}
			                }

			                // if user is in mid-scroll, keep new button accurate
			                _mt2UpdateNewIndicator();
			            }

			            function setupWinnersScrollGuard() {
			                const table = $("winnersTable");
			                if (!table) return;

			                if (table.dataset.mt2ScrollGuard === "1") return;
			                table.dataset.mt2ScrollGuard = "1";

			                table.addEventListener("scroll", () => {
			                    STATE.lastScrollAt = performance.now();
			                    // if user returns near top, clear pending
			                    try {
			                        if ((table.scrollTop || 0) <= 10 && (STATE._pendingNewCount || 0) > 0) {
			                            STATE._pendingNewCount = 0;
			                            _mt2UpdateNewIndicator();
			                        }
			                    } catch (_) {}
			                }, {
			                    passive: true
			                });

			                // smart pause while hovering (desktop)
			                table.addEventListener("pointerenter", () => {
			                    STATE._historyHovering = true;
			                    pauseHistory("hover");
			                }, {
			                    passive: true
			                });

			                table.addEventListener("pointerleave", () => {
			                    STATE._historyHovering = false;
			                    resumeHistory("hover");
			                }, {
			                    passive: true
			                });

			                // pause when hidden
			                document.addEventListener("visibilitychange", () => {
			                    if (document.hidden) pauseHistory("hidden");
			                    else resumeHistory("hidden");
			                }, {
			                    passive: true
			                });
			            }

			            // =========================
			            // History row open (user only)
			            // =========================
			            function setupHistoryRowOpen() {
			                const table = $("winnersTable");
			                if (!table) return;

			                const tryOpen = (row) => {
			                    const id = row.getAttribute("data-id");
			                    const entry = STATE.winnersById.get(id);
			                    if (!entry) return;

			                    if (!entry.isUser) {
			                        const now = Date.now();
			                        if (now - STATE.nonUserToastAt > CONFIG.HISTORY.NON_USER_TOAST_COOLDOWN_MS) {
			                            STATE.nonUserToastAt = now;
			                            showToast("Hanya riwayat Anda yang bisa dibuka.", "error", 1800);
			                        }
			                        return;
			                    }

			                    const showUser = String(entry.fullId || entry.displayId || "-");
			                    const prizeShow = String(entry.prize || entry.prizeKey || "-");
			                    const ts = Number(entry.ts || Date.now());

			                    STATE.lastResult = {
			                        userId: showUser,
			                        prizeLabel: prizeShow,
			                        prizeDisplay: prizeShow,
			                        ts
			                    };

			                    const prizeAmount = $("prizeAmount");
			                    const modalUserId = $("modalUserId");
			                    const modalTime = $("modalTime");

			                    if (prizeAmount) prizeAmount.textContent = prizeShow;
			                    if (modalUserId) modalUserId.textContent = showUser;
			                    if (modalTime) {
			                        modalTime.textContent = new Date(ts).toLocaleString("id-ID", {
			                            day: "2-digit",
			                            month: "short",
			                            year: "numeric",
			                            hour: "2-digit",
			                            minute: "2-digit",
			                            second: "2-digit",
			                        });
			                    }

			                    openModal();
			                };

			                table.addEventListener("click", (e) => {
			                    const row = e.target && e.target.closest ? e.target.closest(".winners-table-row") : null;
			                    if (!row) return;
			                    tryOpen(row);
			                });

			                table.addEventListener("keydown", (e) => {
			                    if (e.key !== "Enter" && e.key !== " ") return;
			                    const row =
			                        e.target && e.target.classList && e.target.classList.contains("winners-table-row") ?
			                        e.target :
			                        null;
			                    if (!row) return;
			                    e.preventDefault();
			                    tryOpen(row);
			                });
			            }

			            // =========================
			            // JACKPOT — REAL CASINO (smooth odometer + natural drift + spike ramp + low-end smart)
			            // =========================
			            const _mt2IDR_FMT = new Intl.NumberFormat("id-ID");

			            function fmtClock() {
			                const d = new Date();
			                return `${pad2(d.getHours())}:${pad2(d.getMinutes())}:${pad2(d.getSeconds())}`;
			            }

			            function _mt2FmtIDR(n) {
			                const v = Math.max(0, Math.round(Number(n) || 0));
			                return `IDR ${_mt2IDR_FMT.format(v)}`;
			            }

			            function ensureJackpotStylesOnce() {
			                if (document.getElementById("mt2-jackpot-style")) return;
			                const st = document.createElement("style");
			                st.id = "mt2-jackpot-style";
			                st.textContent = `
			  #jackpot{
			    font-variant-numeric: tabular-nums;
			    letter-spacing: .6px;
			    text-shadow:
			      0 2px 0 rgba(0,0,0,.22),
			      0 18px 42px rgba(0,0,0,.55),
			      0 0 24px rgba(243,178,74,.10),
			      0 0 18px rgba(34,197,94,.08);
			    transform: translateZ(0);
			    will-change: transform, filter;
			  }
			  #jackpot.mt2-jp-flash{
			    animation: mt2JpFlash 520ms ease-out 1;
			  }
			  #jackpot.mt2-jp-spike{
			    animation: mt2JpSpike 820ms cubic-bezier(.18,.82,.18,1) 1;
			  }
			  @keyframes mt2JpFlash{
			    0%{ filter: brightness(1.0); transform: translateZ(0) scale(1); }
			    35%{ filter: brightness(1.12); transform: translateZ(0) scale(1.015); }
			    100%{ filter: brightness(1.0); transform: translateZ(0) scale(1); }
			  }
			  @keyframes mt2JpSpike{
			    0%{ filter: brightness(1.0); transform: translateZ(0) scale(1); }
			    28%{ filter: brightness(1.18); transform: translateZ(0) scale(1.03); }
			    62%{ filter: brightness(1.07); transform: translateZ(0) scale(1.012); }
			    100%{ filter: brightness(1.0); transform: translateZ(0) scale(1); }
			  }
			  @media (prefers-reduced-motion: reduce){
			    #jackpot.mt2-jp-flash, #jackpot.mt2-jp-spike{ animation:none !important; }
			  }
			  `;
			                document.head.appendChild(st);
			            }

			            function _mt2RandNorm() {
			                // gaussian-ish (Box-Muller)
			                let u = 0,
			                    v = 0;
			                while (u === 0) u = Math.random();
			                while (v === 0) v = Math.random();
			                return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
			            }

			            function _mt2JackpotFlash(kind = "flash") {
			                const el = $("jackpot");
			                if (!el || isReducedMotion()) return;
			                const cls = kind === "spike" ? "mt2-jp-spike" : "mt2-jp-flash";
			                try {
			                    el.classList.remove("mt2-jp-flash", "mt2-jp-spike");
			                    void el.offsetWidth;
			                    el.classList.add(cls);
			                } catch (_) {}
			            }

			            function initJackpot() {
			                const saved = Number(lsGet(LS.JACKPOT_VAL, "0") || "0");
			                if (saved && saved > 1_000_000) return saved;

			                const seed = randInt(CONFIG.JACKPOT.SEED_MIN, CONFIG.JACKPOT.SEED_MAX);
			                lsSet(LS.JACKPOT_VAL, String(seed));
			                return seed;
			            }

			            function startJackpot() {
			                if (STATE.jackpotTimer) return;

			                ensureJackpotStylesOnce();

			                const el = $("jackpot");
			                const meta = $("jackpotMeta");

			                // low-end hint (reuse body class if detectLowEnd() already runs)
			                let lowEnd = false;
			                try {
			                    lowEnd = document.body.classList.contains("low-end");
			                } catch (_) {}
			                if (!lowEnd) {
			                    try {
			                        const devMem = Number(navigator.deviceMemory || 0) || 0;
			                        const cores = Number(navigator.hardwareConcurrency || 0) || 0;
			                        const saveData = !!(navigator.connection && navigator.connection.saveData);
			                        lowEnd = saveData || (devMem && devMem <= 2) || (cores && cores <= 4);
			                    } catch (_) {}
			                }

			                // init values
			                const seeded = Number(STATE.jackpot || 0) || initJackpot();
			                STATE.jackpot = Math.max(CONFIG.JACKPOT.MIN, seeded);
			                if (!Number.isFinite(STATE.jackpotDisplay)) STATE.jackpotDisplay = STATE.jackpot;

			                // realistic motion params
			                let baseSpeed = randInt(CONFIG.JACKPOT.SPEED_MIN, CONFIG.JACKPOT.SPEED_MAX); // unit per second feel (scaled by dt)
			                let nextSpeedAt = performance.now() + randInt(1200, 4200);

			                // OU-like noise state (smooth randomness)
			                let noiseState = 0;

			                // spike ramp (smooth in/out)
			                let spikeTarget = 1;
			                let spikeCur = 1;

			                // paint throttling
			                const paintEveryMs = isReducedMotion() ? 120 : (lowEnd ? 66 : 33); // ~8fps reduced, 15fps low, 30fps normal
			                let lastPaint = 0;
			                let lastMeta = 0;

			                // milestone flash
			                let lastK = Math.floor(STATE.jackpot / 1000);

			                // initial paint
			                if (el) el.textContent = _mt2FmtIDR(STATE.jackpotDisplay);
			                if (meta) meta.textContent = `Update: ${fmtClock()}`;

			                let last = performance.now();

			                const step = () => {
			                    const now = performance.now();
			                    const dtRaw = (now - last) / 1000;
			                    const dt = Math.min(Number(CONFIG.JACKPOT.DT_CAP || 0.22) || 0.22, Math.max(0.001, dtRaw));
			                    last = now;

			                    // pause-friendly: if tab hidden, slow updates heavily (but keep value stable)
			                    if (document.hidden) {
			                        // still schedule next frame but do almost nothing
			                        STATE.jackpotTimer = requestAnimationFrame(step);
			                        return;
			                    }

			                    // drift base speed occasionally
			                    if (now >= nextSpeedAt) {
			                        const target = randInt(CONFIG.JACKPOT.SPEED_MIN, CONFIG.JACKPOT.SPEED_MAX);
			                        baseSpeed = baseSpeed * 0.82 + target * 0.18;
			                        nextSpeedAt = now + randInt(1300, 5200);
			                    }

			                    // spike logic (smooth ramp)
			                    if (now > STATE.spikeUntilMs) {
			                        spikeTarget = 1;
			                        STATE.spikeMul = 1;

			                        if (Math.random() < CONFIG.JACKPOT.SPIKE_CHANCE) {
			                            const mul =
			                                CONFIG.JACKPOT.SPIKE_MIN_MUL + Math.random() * CONFIG.JACKPOT.SPIKE_EXTRA_MUL;
			                            STATE.spikeMul = mul;
			                            spikeTarget = mul;

			                            STATE.spikeUntilMs =
			                                now + (CONFIG.JACKPOT.SPIKE_MIN_MS + Math.random() * CONFIG.JACKPOT.SPIKE_EXTRA_MS);

			                            _mt2JackpotFlash("spike");
			                        }
			                    }

			                    // ramp spikeCur toward spikeTarget
			                    const spikeFollow = lowEnd ? 6.0 : 9.5; // higher = tighter follow
			                    spikeCur += (spikeTarget - spikeCur) * (1 - Math.exp(-spikeFollow * dt));
			                    spikeCur = clamp(spikeCur, 1, 12);

			                    // smooth noise
			                    // noiseState follows 0 with random pushes -> natural jitter without “shaky”
			                    const noiseK = lowEnd ? 2.8 : 3.6;
			                    const noisePush = _mt2RandNorm() * 0.55;
			                    noiseState += (-noiseState * noiseK + noisePush) * dt;
			                    const noise = noiseState * (Number(CONFIG.JACKPOT.NOISE || 0.8) || 0.8);

			                    // compute velocity
			                    let v = baseSpeed * (1 + noise) * spikeCur;

			                    // occasional tiny retrace (casino “breathing”), but keep bounded
			                    if (Math.random() < CONFIG.JACKPOT.NEG_CHANCE) {
			                        v *= (Number(CONFIG.JACKPOT.NEG_MUL || -0.25) || -0.25);
			                        v = Math.max(v, -baseSpeed * 0.35);
			                    }

			                    // update target jackpot
			                    const minJp = Number(CONFIG.JACKPOT.MIN || 0) || 0;
			                    STATE.jackpot = Math.max(minJp, STATE.jackpot + v * dt);

			                    // display smoothing (odometer feel): display chases target
			                    const follow = lowEnd ? 10.0 : 14.5; // responsiveness
			                    const a = 1 - Math.exp(-follow * dt);
			                    STATE.jackpotDisplay = STATE.jackpotDisplay + (STATE.jackpot - STATE.jackpotDisplay) * a;

			                    // milestone flash per 1k (light)
			                    const kNow = Math.floor(STATE.jackpot / 1000);
			                    if (kNow !== lastK) {
			                        lastK = kNow;
			                        if ((kNow % 25) === 0) _mt2JackpotFlash("flash"); // every 25k steps feels premium, not spam
			                    }

			                    // paint throttle
			                    if (now - lastPaint >= paintEveryMs) {
			                        lastPaint = now;

			                        if (el) {
			                            const txt = _mt2FmtIDR(STATE.jackpotDisplay);
			                            if (el.textContent !== txt) el.textContent = txt;
			                        }

			                        if (meta && now - lastMeta >= 1000) {
			                            lastMeta = now;
			                            meta.textContent = `Update: ${fmtClock()}`;
			                        }
			                    }

			                    STATE.jackpotTimer = requestAnimationFrame(step);
			                };

			                // start rAF
			                STATE.jackpotTimer = requestAnimationFrame(step);

			                // periodic save (stable)
			                if (STATE.jackpotSaveTimer) clearInterval(STATE.jackpotSaveTimer);
			                STATE.jackpotSaveTimer = setInterval(() => {
			                    try {
			                        lsSet(LS.JACKPOT_VAL, String(Math.round(STATE.jackpot)));
			                    } catch (_) {}

			                    // occasionally re-roll baseSpeed to avoid robotic feel
			                    if (Math.random() < 0.55) {
			                        const t = randInt(CONFIG.JACKPOT.SPEED_MIN, CONFIG.JACKPOT.SPEED_MAX);
			                        baseSpeed = baseSpeed * 0.8 + t * 0.2;
			                    }
			                }, CONFIG.JACKPOT.SAVE_MS);

			                // optional: one-time visibility hook (if not already elsewhere)
			                if (!STATE._jackpotVisBound) {
			                    STATE._jackpotVisBound = true;
			                    document.addEventListener("visibilitychange", () => {
			                        if (document.hidden) {
			                            // keep timers but reduce cost: stop rAF, resume on visible
			                            if (STATE.jackpotTimer) cancelAnimationFrame(STATE.jackpotTimer);
			                            STATE.jackpotTimer = 0;
			                        } else {
			                            if (!STATE.jackpotTimer) {
			                                // restart smoothly
			                                startJackpot();
			                            }
			                        }
			                    }, {
			                        passive: true
			                    });
			                }
			            }

			            function stopJackpot() {
			                if (STATE.jackpotTimer) cancelAnimationFrame(STATE.jackpotTimer);
			                STATE.jackpotTimer = 0;
			                if (STATE.jackpotSaveTimer) clearInterval(STATE.jackpotSaveTimer);
			                STATE.jackpotSaveTimer = 0;
			            }

			            // =========================
			            // MODAL (focus trap + inert)
			            // =========================
			            function isModalOpen() {
			                const m = $("prizeModal");
			                return !!(m && m.classList.contains("show"));
			            }

			            function trapFocus(e) {
			                const modal = $("prizeModal");
			                const root = modal && modal.querySelector ? modal.querySelector(".modal-content") : null;
			                if (!root) return;

			                const focusables = root.querySelectorAll(
			                    'button,[href],input,select,textarea,[tabindex]:not([tabindex="-1"])'
			                );
			                const list = Array.from(focusables).filter((el) => el && !el.disabled && el.offsetParent !== null);
			                if (list.length === 0) return;

			                const first = list[0];
			                const last = list[list.length - 1];
			                const active = document.activeElement;

			                if (e.shiftKey) {
			                    if (active === first || active === root) {
			                        e.preventDefault();
			                        last.focus({
			                            preventScroll: true
			                        });
			                    }
			                } else {
			                    if (active === last) {
			                        e.preventDefault();
			                        first.focus({
			                            preventScroll: true
			                        });
			                    }
			                }
			            }

			            function openModal() {
			                const modal = $("prizeModal");
			                if (!modal) return;

			                STATE.lastFocusedEl = document.activeElement;

			                pauseHistory("modal");
			                setInert("modal", true);

			                modal.classList.add("show");
			                modal.setAttribute("aria-hidden", "false");
			                setBodyLock(true);

			                const claimBtn = $("claimBtn");
			                if (claimBtn) setTimeout(() => claimBtn.focus({
			                    preventScroll: true
			                }), 0);
			            }

			            function closeModal() {
			                const modal = $("prizeModal");
			                if (!modal) return;

			                modal.classList.remove("show");
			                modal.setAttribute("aria-hidden", "true");

			                resumeHistory("modal");
			                setInert("modal", false);

			                if (!isNavOpen()) setBodyLock(false);

			                if (
			                    STATE.lastFocusedEl &&
			                    STATE.lastFocusedEl.isConnected &&
			                    typeof STATE.lastFocusedEl.focus === "function"
			                ) {
			                    STATE.lastFocusedEl.focus({
			                        preventScroll: true
			                    });
			                }
			                STATE.lastFocusedEl = null;
			            }

			            // =========================
			            // UI
			            // =========================
			            function updateUI() {
			                const spinBtn = $("spinBtn");
			                const userIdInput = $("userIdInput");
			                const spunMessage = $("spunMessage");
			                if (!spinBtn || !userIdInput || !spunMessage) return;

			                if (STATE.hasSpun) {
			                    spinBtn.disabled = true;
			                    spinBtn.textContent = "SUDAH SPIN";
			                    userIdInput.disabled = true;
			                    spunMessage.style.display = "block";
			                } else {
			                    spinBtn.disabled = false;
			                    spinBtn.textContent = "SPIN SEKARANG!";
			                    userIdInput.disabled = false;
			                    spunMessage.style.display = "none";
			                }
			            }

			            // =========================
			            // SPIN (LOCK BONUS 10% + calibrated + RAF sync)
			            // =========================
			            function startSpin() {
			                kickAudio(true);

			                const reduceMotion = isReducedMotion();

			                const userIdInput = $("userIdInput");
			                if (!userIdInput) {
			                    showToast("Input USER ID tidak ditemukan.", "error");
			                    return;
			                }

			                const userId = normalizeUserIdInput(userIdInput.value);
			                userIdInput.value = userId;

			                if (!userId) {
			                    showToast("Masukkan User ID terlebih dahulu!", "error");
			                    userIdInput.focus({
			                        preventScroll: true
			                    });
			                    return;
			                }
			                if (STATE.hasSpun) {
			                    showToast("Anda sudah melakukan spin! Kesempatan hanya 1x.", "error");
			                    return;
			                }
			                if (STATE.isSpin) return;

			                const wheel = $("wheel");
			                if (!wheel) {
			                    showToast("Wheel tidak ditemukan.", "error");
			                    return;
			                }

			                focusWheelIntoView();

			                STATE.isSpin = true;
			                pauseHistory("spin");

			                STATE.spinToken++;
			                const localToken = STATE.spinToken;

			                stopSpinDriver(true);

			                if (STATE.pointerEl) STATE.pointerEl.classList.add("is-spin");

			                const spinBtn = $("spinBtn");
			                if (spinBtn) {
			                    spinBtn.disabled = true;
			                    spinBtn.textContent = "SPINNING…";
			                }

			                try {
			                    wheel.style.willChange = "transform";
			                } catch (_) {}
			                wheel.style.animationTimingFunction = SPIN_EASING_CSS;

			                const prizeIndex = BONUS_INDEX >= 0 ? BONUS_INDEX : 0;

			                const n = PRIZES.length || 1;
			                const segmentAngle = 360 / n;

			                const startOff = Number(CONFIG.WHEEL.START_OFFSET_DEG || 0);
			                const pointerAt = Number(CONFIG.WHEEL.POINTER_AT_DEG || 0);

			                const segmentCenter = prizeIndex * segmentAngle + segmentAngle / 2 + startOff;
			                const base = ((STATE.currentRotation % 360) + 360) % 360;
			                const desiredMod = (((pointerAt - segmentCenter) % 360) + 360) % 360;

			                const fullSpins =
			                    360 * (CONFIG.WHEEL.FULL_SPINS_MIN + Math.floor(Math.random() * CONFIG.WHEEL.FULL_SPINS_EXTRA));
			                const jitter = (Math.random() - 0.5) * (segmentAngle * CONFIG.WHEEL.JITTER_SEGMENT_FRAC);

			                const delta = (desiredMod - base + 360) % 360;
			                const totalRotation = STATE.currentRotation + fullSpins + delta + jitter;
			                const rotationDelta = totalRotation - STATE.currentRotation;

			                const durationMs = reduceMotion ? 350 : CONFIG.SPIN_DURATION_MS;
			                wheel.style.setProperty("--spin-dur", durationMs + "ms");

			                // ✅ RAF driver (tick + spinSound sinkron)
			                startSpinDriver(STATE.currentRotation, rotationDelta, segmentAngle, durationMs, localToken);

			                let ended = false;

			                const onEnd = () => {
			                    if (ended) return;
			                    if (localToken !== STATE.spinToken) return;
			                    ended = true;

			                    stopSpinDriver(true);

			                    wheel.classList.remove("spinning");
			                    applyWheelRotation(totalRotation);
			                    saveRotation(totalRotation);

			                    try {
			                        wheel.style.willChange = "";
			                    } catch (_) {}

			                    const winSound = $("winSound");
			                    try {
			                        if (winSound) {
			                            winSound.currentTime = 0;
			                            winSound.play().catch(() => {});
			                        }
			                    } catch (_) {}

			                    if (STATE.pointerEl) STATE.pointerEl.classList.remove("is-spin");

			                    STATE.hasSpun = true;
			                    STATE.spinAt = Date.now();
			                    lsSet(LS.HAS_SPUN, "true");
			                    lsSet(LS.SPIN_AT, String(STATE.spinAt));
			                    lsSet(LS.LAST_USER_ID, userId);
			                    STATE.savedUserId = userId;

			                    STATE.lastResult = {
			                        userId,
			                        prizeLabel: BONUS_LABEL,
			                        prizeDisplay: CONFIG.PRIZE_DISPLAY_MAP[BONUS_LABEL],
			                        ts: STATE.spinAt,
			                    };

			                    const prizeAmount = $("prizeAmount");
			                    const modalUserId = $("modalUserId");
			                    const modalTime = $("modalTime");

			                    if (prizeAmount) prizeAmount.textContent = BONUS_LABEL;
			                    if (modalUserId) modalUserId.textContent = userId;
			                    if (modalTime) {
			                        modalTime.textContent = new Date(STATE.spinAt).toLocaleString("id-ID", {
			                            day: "2-digit",
			                            month: "short",
			                            year: "numeric",
			                            hour: "2-digit",
			                            minute: "2-digit",
			                            second: "2-digit",
			                        });
			                    }

			                    const existing = STATE.winners.find((w) => w.isUser === true);
			                    if (existing) {
			                        existing.fullId = userId;
			                        existing.displayId = userId;
			                        existing.prizeKey = BONUS_LABEL;
			                        existing.prize = CONFIG.PRIZE_DISPLAY_MAP[BONUS_LABEL];
			                        existing.ts = STATE.spinAt;
			                        existing.isNew = true;
			                        existing.id = existing.id || makeEntryId("user");
			                        renderWinners({
			                            preserveScroll: true
			                        });
			                    } else {
			                        pushWinnerEntry({
			                            id: makeEntryId("user"),
			                            isUser: true,
			                            fullId: userId,
			                            displayId: userId,
			                            prizeKey: BONUS_LABEL,
			                            prize: CONFIG.PRIZE_DISPLAY_MAP[BONUS_LABEL],
			                            ts: STATE.spinAt,
			                            isNew: true,
			                        });
			                    }

			                    updateUI();
			                    celebrateWin();

			                    openModal();
			                    resumeHistory("spin");

			                    STATE.isSpin = false;
			                };

			                if (reduceMotion) {
			                    onEnd();
			                    return;
			                }

			                wheel.style.setProperty("--from-rotation", STATE.currentRotation + "deg");
			                wheel.style.setProperty("--rotation", totalRotation + "deg");
			                wheel.classList.add("spinning");

			                wheel.addEventListener("animationend", onEnd, {
			                    once: true
			                });
			                setTimeout(() => {
			                    if (localToken === STATE.spinToken) onEnd();
			                }, durationMs + 260);
			            }

			            // =========================
			            // PNG DOWNLOAD (ctx fallback safe) — MINIMAL CARD + GIFT TOP RIGHT
			            // =========================
			            let MEASURE_CTX = null;

			            function getMeasureCtx() {
			                if (MEASURE_CTX) return MEASURE_CTX;
			                try {
			                    const c = document.createElement("canvas");
			                    c.width = 32;
			                    c.height = 32;
			                    MEASURE_CTX = c.getContext("2d") || null;
			                } catch (_) {
			                    MEASURE_CTX = null;
			                }
			                return MEASURE_CTX;
			            }

			            function drawOrb(ctx, x, y, r, color) {
			                const g = ctx.createRadialGradient(x, y, 0, x, y, r);
			                g.addColorStop(0, color);
			                g.addColorStop(1, "rgba(0,0,0,0)");
			                ctx.fillStyle = g;
			                ctx.beginPath();
			                ctx.arc(x, y, r, 0, Math.PI * 2);
			                ctx.fill();
			            }

			            function roundRect(ctx, x, y, w, h, r) {
			                const rr = Math.min(r, w / 2, h / 2);
			                ctx.beginPath();
			                ctx.moveTo(x + rr, y);
			                ctx.arcTo(x + w, y, x + w, y + h, rr);
			                ctx.arcTo(x + w, y + h, x, y + h, rr);
			                ctx.arcTo(x, y + h, x, y, rr);
			                ctx.arcTo(x, y, x + w, y, rr);
			                ctx.closePath();
			            }

			            function drawGiftIcon(ctx, x, y, size) {
			                const w = size,
			                    h = size * 0.92;
			                const box = "#10B981";
			                const lid = "#059669";

			                ctx.save();
			                ctx.shadowColor = "rgba(0,0,0,0.26)";
			                ctx.shadowBlur = 14;
			                ctx.shadowOffsetY = 8;

			                roundRect(ctx, x, y + size * 0.22, w, h - size * 0.22, size * 0.16);
			                ctx.fillStyle = box;
			                ctx.fill();

			                roundRect(ctx, x, y + size * 0.14, w, size * 0.18, size * 0.14);
			                ctx.fillStyle = lid;
			                ctx.fill();

			                ctx.shadowColor = "transparent";
			                ctx.fillStyle = "rgba(255,255,255,0.06)";
			                roundRect(ctx, x, y + size * 0.14, w, size * 0.18, size * 0.14);
			                ctx.fill();
			                roundRect(ctx, x, y + size * 0.22, w, h - size * 0.22, size * 0.16);
			                ctx.fill();
			                ctx.restore();

			                const rg = ctx.createLinearGradient(x, y, x, y + h);
			                rg.addColorStop(0, "#FDBA74");
			                rg.addColorStop(0.55, "#FB923C");
			                rg.addColorStop(1, "#F59E0B");

			                roundRect(ctx, x + w * 0.45, y + size * 0.14, w * 0.1, h - size * 0.14, w * 0.06);
			                ctx.fillStyle = rg;
			                ctx.fill();

			                ctx.save();
			                ctx.strokeStyle = "#FB923C";
			                ctx.lineWidth = Math.max(3.5, size * 0.1);
			                ctx.lineCap = "round";
			                ctx.lineJoin = "round";
			                const cx = x + w * 0.5;
			                const top = y + size * 0.08;

			                ctx.beginPath();
			                ctx.moveTo(cx, y + size * 0.18);
			                ctx.bezierCurveTo(
			                    cx - w * 0.18,
			                    top,
			                    cx - w * 0.34,
			                    top + size * 0.06,
			                    cx - w * 0.2,
			                    y + size * 0.22
			                );
			                ctx.stroke();

			                ctx.beginPath();
			                ctx.moveTo(cx, y + size * 0.18);
			                ctx.bezierCurveTo(
			                    cx + w * 0.18,
			                    top,
			                    cx + w * 0.34,
			                    top + size * 0.06,
			                    cx + w * 0.2,
			                    y + size * 0.22
			                );
			                ctx.stroke();
			                ctx.restore();

			                ctx.fillStyle = "rgba(255,255,255,0.20)";
			                roundRect(ctx, x + w * 0.12, y + size * 0.44, w * 0.06, h * 0.38, w * 0.03);
			                ctx.fill();
			                ctx.fillStyle = "rgba(255,255,255,0.14)";
			                roundRect(ctx, x + w * 0.12, y + size * 0.84, w * 0.06, h * 0.1, w * 0.03);
			                ctx.fill();
			            }

			            function fitTextWithEllipsis(ctx, text, maxWidth) {
			                const ell = "…";
			                const t0 = String(text || "");
			                if (!ctx) return t0;
			                if (ctx.measureText(t0).width <= maxWidth) return t0;

			                let t = t0;
			                while (t.length > 1 && ctx.measureText(t + ell).width > maxWidth) t = t.slice(0, -1);
			                return t.trim() + ell;
			            }

			            function wrapLinesByWords(ctx, text, maxWidth, maxLines) {
			                const words = String(text || "")
			                    .split(/\s+/)
			                    .filter(Boolean);
			                const lines = [];
			                let line = "";

			                for (let i = 0; i < words.length; i++) {
			                    const test = line ? line + " " + words[i] : words[i];
			                    const w = ctx ? ctx.measureText(test).width : test.length * 12;

			                    if (w <= maxWidth) {
			                        line = test;
			                        continue;
			                    }
			                    if (line) lines.push(line);
			                    line = words[i];

			                    if (lines.length === maxLines - 1) break;
			                }
			                if (line) lines.push(line);

			                if (lines.length === maxLines && ctx) {
			                    const lastIdx = maxLines - 1;
			                    lines[lastIdx] = fitTextWithEllipsis(ctx, lines[lastIdx], maxWidth);
			                }
			                return lines;
			            }

			            function layoutAdaptiveHeadline(ctx, text, maxWidth, opt) {
			                const t = String(text || "").trim();
			                const maxFont = opt.maxFont || 80;
			                const minFont = opt.minFont || 54;
			                const weight = opt.weight || 1000;
			                const family = opt.family || "system-ui, -apple-system, Segoe UI, Roboto, Arial";
			                const maxLines = opt.maxLines || 2;
			                const lineHScale = opt.lineHScale || 0.9;

			                if (!ctx) {
			                    const fontSize = maxFont;
			                    const lineH = Math.ceil(fontSize * lineHScale);
			                    return {
			                        fontSize,
			                        lineH,
			                        lines: [t]
			                    };
			                }

			                let fontSize = maxFont;
			                let lines = [t];

			                while (fontSize >= minFont) {
			                    ctx.font = `${weight} ${fontSize}px ${family}`;
			                    lines = wrapLinesByWords(ctx, t, maxWidth, maxLines);
			                    if (lines.length <= maxLines) break;
			                    fontSize -= 2;
			                }

			                const lineH = Math.ceil(fontSize * lineHScale);
			                return {
			                    fontSize,
			                    lineH,
			                    lines
			                };
			            }

			            function calcRewardPngLayout(r, ts) {
			                const baseW = CONFIG.PNG.BASE_W;

			                const pad = 56;
			                const cardX = pad;
			                const cardY = 96;
			                const cardW = baseW - pad * 2;

			                const innerPadX = 40;
			                const innerX = cardX + innerPadX;
			                const innerW = cardW - innerPadX * 2;

			                const cardR = 28;
			                const cardStroke = 3;

			                const topPad = 44;
			                const brandY = cardY + topPad + 24;
			                const subY = brandY + 32;

			                const giftSize = 46;
			                const giftX = innerX + innerW - giftSize;
			                const giftY = cardY + topPad - 2;

			                const brandX = innerX;
			                const brandMaxW = innerW - giftSize - 16;

			                const prizeStartY = subY + 78;
			                const prizeText = String((r && r.prizeLabel) || BONUS_LABEL);

			                const mctx = getMeasureCtx();
			                const prize = layoutAdaptiveHeadline(mctx, prizeText, innerW, {
			                    maxFont: 80,
			                    minFont: 54,
			                    weight: 1000,
			                    family: "system-ui, -apple-system, Segoe UI, Roboto, Arial",
			                    lineHScale: 0.9,
			                    maxLines: 2,
			                });

			                const prizeBlockH = Math.ceil((prize.lines.length - 1) * prize.lineH + prize.fontSize * 1.1);
			                const prizeBottom = prizeStartY + prizeBlockH;

			                const dividerY = Math.ceil(prizeBottom + 10);

			                const userLabelY = dividerY + 52;
			                const userValueY = userLabelY + 30;

			                const timeLabelY = userValueY + 50;
			                const timeValueY = timeLabelY + 30;

			                const noteY = Math.ceil(timeValueY + 40);
			                const noteX = innerX;
			                const noteW = innerW;

			                const noteText = CONFIG.PNG.NOTE_TEXT;
			                const noteFont = "800 19px system-ui, -apple-system, Segoe UI, Roboto, Arial";
			                const noteLineH = 24;

			                const noteInnerPadX = 22;
			                const noteInnerPadY = 16;
			                const noteMaxW = noteW - noteInnerPadX * 2;

			                let noteLines = [noteText];
			                const maxNoteLines = Math.min(2, Number(CONFIG.PNG.NOTE_MAX_LINES || 2) || 2);

			                if (mctx) {
			                    mctx.font = noteFont;
			                    noteLines = wrapLinesByWords(mctx, noteText, noteMaxW, maxNoteLines);
			                } else {
			                    noteLines = [noteText.slice(0, 52), noteText.slice(52, 104)]
			                        .filter(Boolean)
			                        .slice(0, maxNoteLines);
			                }

			                const noteH = Math.max(56, noteInnerPadY * 2 + noteLines.length * noteLineH + 2);
			                const noteR = 18;

			                const noteTextX = noteX + noteInnerPadX;
			                const noteTextY = noteY + noteInnerPadY + 18;

			                const footerY = Math.ceil(noteY + noteH + 34);

			                const cardH = Math.ceil(footerY + 24 - cardY);
			                const baseH = Math.ceil(cardY + cardH + 80);

			                return {
			                    baseW,
			                    baseH,
			                    cardX,
			                    cardY,
			                    cardW,
			                    cardH,
			                    innerX,
			                    innerW,

			                    cardR,
			                    cardStroke,

			                    brandX,
			                    brandY,
			                    subY,
			                    brandMaxW,

			                    giftX,
			                    giftY,
			                    giftSize,

			                    prizeStartY,
			                    prize,
			                    dividerY,

			                    userLabelY,
			                    userValueY,
			                    timeLabelY,
			                    timeValueY,

			                    noteX,
			                    noteY,
			                    noteW,
			                    noteH,
			                    noteR,
			                    noteLines,
			                    noteLineH,
			                    noteTextX,
			                    noteTextY,

			                    footerY,
			                };
			            }

			            function renderRewardPngToCanvas(ctx, lay, r, ts) {
			                const g = ctx.createLinearGradient(0, 0, lay.baseW, lay.baseH);
			                g.addColorStop(0, "#06130f");
			                g.addColorStop(0.55, "#071e16");
			                g.addColorStop(1, "#05281d");
			                ctx.fillStyle = g;
			                ctx.fillRect(0, 0, lay.baseW, lay.baseH);

			                drawOrb(ctx, lay.baseW * 0.22, lay.baseH * 0.18, 240, "rgba(34,197,94,0.10)");
			                drawOrb(ctx, lay.baseW * 0.86, lay.baseH * 0.3, 190, "rgba(255,255,255,0.05)");

			                roundRect(ctx, lay.cardX, lay.cardY, lay.cardW, lay.cardH, lay.cardR);
			                const cg = ctx.createLinearGradient(
			                    lay.cardX,
			                    lay.cardY,
			                    lay.cardX + lay.cardW,
			                    lay.cardY + lay.cardH
			                );
			                cg.addColorStop(0, "rgba(6,18,14,0.92)");
			                cg.addColorStop(1, "rgba(7,30,22,0.92)");
			                ctx.fillStyle = cg;
			                ctx.fill();

			                ctx.lineWidth = lay.cardStroke;
			                ctx.strokeStyle = "rgba(34,197,94,0.42)";
			                ctx.stroke();

			                ctx.save();
			                ctx.globalAlpha = 0.55;
			                ctx.lineWidth = 1.5;
			                ctx.strokeStyle = "rgba(255,255,255,0.06)";
			                roundRect(
			                    ctx,
			                    lay.cardX + 10,
			                    lay.cardY + 10,
			                    lay.cardW - 20,
			                    lay.cardH - 20,
			                    Math.max(10, lay.cardR - 10)
			                );
			                ctx.stroke();
			                ctx.restore();

			                if (lay.giftSize > 0) drawGiftIcon(ctx, lay.giftX, lay.giftY, lay.giftSize);

			                ctx.fillStyle = "rgba(255,255,255,0.96)";
			                ctx.font = "900 40px system-ui, -apple-system, Segoe UI, Roboto, Arial";
			                const brandText = fitTextWithEllipsis(ctx, "MADETOTO2", lay.brandMaxW);
			                ctx.fillText(brandText, lay.brandX, lay.brandY);

			                ctx.fillStyle = "rgba(255,255,255,0.72)";
			                ctx.font = "800 20px system-ui, -apple-system, Segoe UI, Roboto, Arial";
			                ctx.fillText("HASIL SPIN HADIAH", lay.brandX, lay.subY);

			                ctx.fillStyle = "#bbf7d0";
			                ctx.font = `1000 ${lay.prize.fontSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
			                ctx.save();
			                ctx.shadowColor = "rgba(0,0,0,0.22)";
			                ctx.shadowBlur = 14;
			                ctx.shadowOffsetY = 8;
			                for (let i = 0; i < lay.prize.lines.length; i++) {
			                    ctx.fillText(lay.prize.lines[i], lay.innerX, lay.prizeStartY + i * lay.prize.lineH);
			                }
			                ctx.restore();

			                ctx.strokeStyle = "rgba(255,255,255,0.08)";
			                ctx.lineWidth = 1.5;
			                ctx.beginPath();
			                ctx.moveTo(lay.innerX, lay.dividerY);
			                ctx.lineTo(lay.innerX + lay.innerW, lay.dividerY);
			                ctx.stroke();

			                ctx.fillStyle = "rgba(255,255,255,0.62)";
			                ctx.font =
			                    "800 18px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Courier New', monospace";
			                ctx.fillText("USER ID", lay.innerX, lay.userLabelY);
			                ctx.fillText("WAKTU", lay.innerX, lay.timeLabelY);

			                ctx.fillStyle = "rgba(255,255,255,0.94)";
			                ctx.font =
			                    "900 28px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Courier New', monospace";
			                const uid = fitTextWithEllipsis(ctx, String((r && r.userId) || "-"), lay.innerW);
			                ctx.fillText(uid, lay.innerX, lay.userValueY);

			                let timeStr = "";
			                try {
			                    timeStr = new Date(ts).toLocaleString("id-ID", {
			                        day: "2-digit",
			                        month: "short",
			                        year: "numeric",
			                        hour: "2-digit",
			                        minute: "2-digit",
			                        second: "2-digit",
			                    });
			                } catch (_) {
			                    timeStr = String(ts || "");
			                }
			                timeStr = fitTextWithEllipsis(ctx, timeStr, lay.innerW);
			                ctx.fillText(timeStr, lay.innerX, lay.timeValueY);

			                roundRect(ctx, lay.noteX, lay.noteY, lay.noteW, lay.noteH, lay.noteR);
			                ctx.fillStyle = "rgba(0,0,0,0.28)";
			                ctx.fill();
			                ctx.strokeStyle = "rgba(255,255,255,0.08)";
			                ctx.lineWidth = 1.5;
			                ctx.stroke();

			                ctx.fillStyle = "rgba(255,255,255,0.86)";
			                ctx.font = "800 19px system-ui, -apple-system, Segoe UI, Roboto, Arial";
			                for (let i = 0; i < lay.noteLines.length; i++) {
			                    ctx.fillText(lay.noteLines[i], lay.noteTextX, lay.noteTextY + i * lay.noteLineH);
			                }

			                ctx.fillStyle = "rgba(255,255,255,0.46)";
			                ctx.font = "700 16px system-ui, -apple-system, Segoe UI, Roboto, Arial";
			                ctx.fillText("Spin & Win • MADETOTO2", lay.innerX, lay.footerY);
			            }

			            function renderRewardPngCanvasForShare() {
			                const r = STATE.lastResult;
			                const ts = (r && r.ts) || Date.now();
			                const dpr = 2;

			                const lay = calcRewardPngLayout(r, ts);
			                const canvas = document.createElement("canvas");
			                canvas.width = Math.floor(lay.baseW * dpr);
			                canvas.height = Math.floor(lay.baseH * dpr);

			                const ctx = canvas.getContext("2d");
			                if (!ctx) return canvas;

			                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
			                renderRewardPngToCanvas(ctx, lay, r, ts);
			                return canvas;
			            }

			            function buildFileName(userId, ts) {
			                const d = new Date(ts || Date.now());
			                const y = d.getFullYear();
			                const m = pad2(d.getMonth() + 1);
			                const da = pad2(d.getDate());
			                const hh = pad2(d.getHours());
			                const mm = pad2(d.getMinutes());
			                const safeId =
			                    String(userId || "USER")
			                    .replace(/[^A-Z0-9_-]/gi, "")
			                    .slice(0, 18) || "USER";
			                return `MADETOTO2-HADIAH-${safeId}-${y}${m}${da}-${hh}${mm}.png`;
			            }

			            function triggerDownload(url, filename) {
			                const a = document.createElement("a");
			                a.href = url;
			                a.download = filename;
			                a.rel = "noopener";
			                a.target = "_blank";
			                document.body.appendChild(a);
			                a.click();
			                a.remove();

			                setTimeout(() => {
			                    try {
			                        if (/iPhone|iPad|iPod/i.test(navigator.userAgent || ""))
			                            window.open(url, "_blank", "noopener,noreferrer");
			                    } catch (_) {}
			                }, 120);
			            }

			            function downloadResultPng() {
			                if (!STATE.lastResult) {
			                    showToast("Hasil belum tersedia. Silakan spin terlebih dahulu.", "error");
			                    return;
			                }
			                try {
			                    kickAudio(true);
			                } catch (_) {}

			                const r = STATE.lastResult;
			                const ts = r.ts || Date.now();

			                const dpr = Math.min(CONFIG.PNG.DPR_CAP, window.devicePixelRatio || 1);
			                const lay = calcRewardPngLayout(r, ts);

			                const canvas = document.createElement("canvas");
			                canvas.width = Math.floor(lay.baseW * dpr);
			                canvas.height = Math.floor(lay.baseH * dpr);

			                const ctx = canvas.getContext("2d");
			                if (!ctx) {
			                    showToast("Browser tidak mendukung unduhan gambar.", "error");
			                    return;
			                }

			                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
			                renderRewardPngToCanvas(ctx, lay, r, ts);

			                const fileName = buildFileName(r.userId, ts);

			                const done = (blobOrDataUrl) => {
			                    try {
			                        if (blobOrDataUrl instanceof Blob) {
			                            const url = URL.createObjectURL(blobOrDataUrl);
			                            triggerDownload(url, fileName);
			                            setTimeout(() => URL.revokeObjectURL(url), 2500);
			                        } else if (typeof blobOrDataUrl === "string") {
			                            triggerDownload(blobOrDataUrl, fileName);
			                        }
			                        showToast("File hasil berhasil dibuat", "success");
			                    } catch (_) {
			                        showToast("Gagal mengunduh. File akan dibuka di tab baru.", "error");
			                        try {
			                            const url =
			                                blobOrDataUrl instanceof Blob ?
			                                URL.createObjectURL(blobOrDataUrl) :
			                                String(blobOrDataUrl || "");
			                            window.open(url, "_blank", "noopener,noreferrer");
			                        } catch (_) {}
			                    }
			                };

			                if (canvas.toBlob) {
			                    canvas.toBlob(
			                        (blob) => {
			                            if (!blob) {
			                                done(canvas.toDataURL("image/png"));
			                                return;
			                            }
			                            done(blob);
			                        },
			                        "image/png",
			                        0.92
			                    );
			                } else {
			                    done(canvas.toDataURL("image/png"));
			                }
			            }

			            // =========================
			            // SHARE UNIVERSAL (1 tombol)
			            // =========================
			            function buildShareUrl() {
			                try {
			                    return location.origin + location.pathname;
			                } catch (_) {}
			                return String(location.href || "");
			            }

			            function buildShareText() {
			                const r = STATE.lastResult || {};
			                const prize = String(r.prizeLabel || r.prizeDisplay || BONUS_LABEL || "HADIAH");
			                const uid = String(r.userId || "-");
			                const ts = Number(r.ts || Date.now());

			                const timeStr = new Date(ts).toLocaleString("id-ID", {
			                    day: "2-digit",
			                    month: "short",
			                    year: "numeric",
			                    hour: "2-digit",
			                    minute: "2-digit",
			                    second: "2-digit",
			                });

			                return `🎁 MADETOTO2 - Spin & Win\n\nSaya mendapatkan: ${prize}\nUser ID: ${uid}\nWaktu: ${timeStr}\n\nCoba juga di: ${buildShareUrl()}`;
			            }

			            async function copyToClipboard(text) {
			                try {
			                    if (navigator.clipboard && navigator.clipboard.writeText) {
			                        await navigator.clipboard.writeText(String(text || ""));
			                        return true;
			                    }
			                } catch (_) {}

			                try {
			                    const ta = document.createElement("textarea");
			                    ta.value = String(text || "");
			                    ta.setAttribute("readonly", "");
			                    ta.style.position = "fixed";
			                    ta.style.left = "-9999px";
			                    ta.style.top = "0";
			                    document.body.appendChild(ta);
			                    ta.select();
			                    document.execCommand("copy");
			                    ta.remove();
			                    return true;
			                } catch (_) {}

			                return false;
			            }

			            function setShareBusy(on) {
			                const shareBtn = $("shareBtn");
			                const downloadBtn = $("downloadBtn");
			                const claimBtn = $("claimBtn");
			                if (shareBtn) shareBtn.disabled = !!on;
			                if (downloadBtn) downloadBtn.disabled = !!on;
			                if (claimBtn) claimBtn.disabled = !!on;
			            }

			            function canvasToBlobAsync(canvas, type = "image/png", quality = 0.92) {
			                return new Promise((resolve) => {
			                    try {
			                        if (!canvas || !canvas.toBlob) return resolve(null);
			                        canvas.toBlob((blob) => resolve(blob || null), type, quality);
			                    } catch (_) {
			                        resolve(null);
			                    }
			                });
			            }

			            async function shareViaWebShare(payload) {
			                try {
			                    if (!navigator.share) return false;
			                    await navigator.share(payload);
			                    return true;
			                } catch (_) {
			                    return false;
			                }
			            }

			            async function shareUniversal() {
			                if (!STATE.lastResult) {
			                    showToast("Hasil belum tersedia.", "error");
			                    return;
			                }
			                try {
			                    kickAudio(true);
			                } catch (_) {}

			                setShareBusy(true);
			                try {
			                    const url = buildShareUrl();
			                    const text = buildShareText();

			                    const basePayload = {
			                        title: "MADETOTO2 - Spin & Win",
			                        text,
			                        url
			                    };
			                    let payload = basePayload;

			                    try {
			                        const canvas = renderRewardPngCanvasForShare();
			                        const blob = await canvasToBlobAsync(canvas, "image/png", 0.92);

			                        if (blob) {
			                            const r = STATE.lastResult || {};
			                            const ts = r.ts || Date.now();
			                            const fileName = buildFileName(r.userId, ts);
			                            const file = new File([blob], fileName, {
			                                type: "image/png"
			                            });

			                            if (navigator.canShare && navigator.canShare({
			                                    files: [file]
			                                })) {
			                                payload = Object.assign({}, basePayload, {
			                                    files: [file]
			                                });
			                            }
			                        }
			                    } catch (_) {}

			                    const ok = await shareViaWebShare(payload);
			                    if (ok) {
			                        showToast("Berhasil dibagikan", "success");
			                        return;
			                    }

			                    const copied = await copyToClipboard(text);
			                    if (copied)
			                        showToast(
			                            "Menu share tidak tersedia. Link sudah dicopy — tinggal paste ke sosmed.",
			                            "success",
			                            3200
			                        );
			                    else showToast("Gagal share/copy. Coba browser lain.", "error", 2600);
			                } finally {
			                    setShareBusy(false);
			                }
			            }

			            // =========================
			            // CLAIM overlay + watchdog (POWER-UP)
			            // =========================
			            let claimInFlight = false;
			            let claimWatchdogT = 0;
			            let claimMinHoldT = 0; // dipakai beneran untuk nahan overlay
			            let claimHideT = 0; // timer untuk anim hide
			            let claimHoldUntil = 0; // timestamp (performance.now) kapan overlay boleh mulai hide

			            function isNavOpen() {
			                const el = $("navLoading");
			                return !!(el && el.classList.contains("show"));
			            }

			            function clearClaimTimers() {
			                if (claimWatchdogT) {
			                    clearTimeout(claimWatchdogT);
			                    claimWatchdogT = 0;
			                }
			                if (claimMinHoldT) {
			                    clearTimeout(claimMinHoldT);
			                    claimMinHoldT = 0;
			                }
			                if (claimHideT) {
			                    clearTimeout(claimHideT);
			                    claimHideT = 0;
			                }
			            }

			            function showNavLoading() {
			                const el = $("navLoading");
			                if (!el) return;

			                pauseHistory("nav");
			                setInert("nav", true);

			                // aksesibilitas + state
			                el.classList.add("show");
			                el.setAttribute("aria-hidden", "false");
			                if (!el.hasAttribute("role")) el.setAttribute("role", "dialog");
			                el.setAttribute("aria-modal", "true");
			                el.tabIndex = -1;

			                try {
			                    el.focus({
			                        preventScroll: true
			                    });
			                } catch (_) {}

			                if (document.body) document.body.setAttribute("aria-busy", "true");
			                setBodyLock(true);

			                const minHold = isReducedMotion() ? 0 : Math.max(0, Number(CONFIG.CLAIM_OVERLAY_MIN_MS || 0));
			                claimHoldUntil = performance.now() + minHold;
			            }

			            function hideNavLoading(immediate = false) {
			                const el = $("navLoading");
			                if (!el) return;

			                const done = () => {
			                    el.classList.remove("show");
			                    el.setAttribute("aria-hidden", "true");

			                    if (document.body) document.body.removeAttribute("aria-busy");

			                    claimInFlight = false;
			                    resumeHistory("nav");
			                    setInert("nav", false);
			                    if (!isModalOpen()) setBodyLock(false);
			                };

			                clearClaimTimers();

			                if (immediate || isReducedMotion()) {
			                    done();
			                    return;
			                }

			                const startHide = () => {
			                    // mulai transisi (CSS kamu biasanya: .show -> visible, remove show -> fade out)
			                    el.classList.remove("show");

			                    // selesai setelah durasi transisi
			                    claimHideT = setTimeout(done, 260);
			                };

			                const holdLeft = Math.max(0, claimHoldUntil - performance.now());
			                if (holdLeft > 0) {
			                    claimMinHoldT = setTimeout(startHide, holdLeft);
			                } else {
			                    startHide();
			                }
			            }

			            function claimPrize() {
			                if (claimInFlight) return;

			                const url = String(CONFIG.CLAIM_URL || "");
			                if (!url) {
			                    showToast("Link klaim belum diatur.", "error", 2400);
			                    return;
			                }

			                claimInFlight = true;

			                closeModal();
			                showNavLoading();

			                // opsional: kalau suatu saat kamu mau buka tab baru (tidak wajib ada key ini)
			                const openNewTab = !!(CONFIG.CLAIM_OPEN_NEW_TAB || CONFIG.CLAIM_NEW_TAB);

			                if (openNewTab) {
			                    let opened = null;
			                    try {
			                        opened = window.open(url, "_blank", "noopener,noreferrer");
			                    } catch (_) {
			                        opened = null;
			                    }
			                    if (opened) {
			                        // karena halaman tidak pindah, overlay harus auto hide (tetap hormati minHold)
			                        hideNavLoading(false);
			                        showToast("Halaman klaim dibuka di tab baru.", "success", 2000);
			                        return;
			                    }
			                    // kalau diblokir popup, jatuh ke same-tab navigation
			                }

			                // watchdog (configurable kalau kamu mau)
			                const watchdogMs = Math.max(4000, Number(CONFIG.CLAIM_WATCHDOG_MS || 10000));
			                claimWatchdogT = setTimeout(() => {
			                    if (isNavOpen() && !document.hidden) {
			                        hideNavLoading(true);
			                        showToast("Gagal membuka halaman klaim. Coba tekan KLAIM lagi.", "error", 2600);
			                    }
			                }, watchdogMs);

			                try {
			                    window.location.assign(url);
			                } catch (_) {
			                    hideNavLoading(true);
			                    showToast("Tidak bisa membuka halaman klaim.", "error", 2400);
			                }
			            }

			            // =========================
			            // CELEBRATE (lebih smooth + lebih aman performa)
			            // =========================
			            let celebrateT = 0;

			            function stopCelebrate() {
			                if (celebrateT) {
			                    clearInterval(celebrateT);
			                    celebrateT = 0;
			                }
			            }

			            function celebrateWin() {
			                if (isReducedMotion()) return;

			                stopCelebrate();

			                const duration = 2200;
			                const startedAt = performance.now();

			                // interval jauh lebih stabil dibanding spam per-frame di device berat
			                celebrateT = setInterval(() => {
			                    const t = performance.now() - startedAt;
			                    if (t >= duration) {
			                        stopCelebrate();
			                        return;
			                    }

			                    // adaptif: burst kecil tapi “sering”, feel casino tetap dapet tanpa ngelag
			                    const burst = (t < 700) ? 10 : 6;

			                    try {
			                        confetti({
			                            particleCount: burst,
			                            angle: 60,
			                            spread: 55,
			                            origin: {
			                                x: 0
			                            }
			                        });
			                        confetti({
			                            particleCount: burst,
			                            angle: 120,
			                            spread: 55,
			                            origin: {
			                                x: 1
			                            }
			                        });
			                    } catch (_) {}
			                }, 90);
			            }

			            // =========================
			            // Persist user entry + rotation consistency (POWER-UP)
			            // =========================
			            function bootPersistedUserEntry() {
			                if (STATE.hasSpun && !STATE.spinAt) {
			                    STATE.spinAt = Date.now();
			                    lsSet(LS.SPIN_AT, String(STATE.spinAt));
			                }

			                // POWER-UP: jangan hardcode BONUS kalau kamu punya penyimpanan prize key
			                const prizeKeyLS = (LS && LS.LAST_PRIZE_KEY) ? LS.LAST_PRIZE_KEY : null;
			                const savedPrizeKey = prizeKeyLS ? String(lsGet(prizeKeyLS, "") || "") : "";
			                const prizeKey = savedPrizeKey || BONUS_LABEL;

			                const prizeDisplay =
			                    (CONFIG.PRIZE_DISPLAY_MAP && CONFIG.PRIZE_DISPLAY_MAP[prizeKey]) ||
			                    (CONFIG.PRIZE_DISPLAY_MAP && CONFIG.PRIZE_DISPLAY_MAP[BONUS_LABEL]) ||
			                    prizeKey;

			                if (STATE.hasSpun && STATE.savedUserId) {
			                    STATE.lastResult = {
			                        userId: STATE.savedUserId,
			                        prizeLabel: prizeKey,
			                        prizeDisplay,
			                        ts: STATE.spinAt || Date.now(),
			                    };

			                    const existing = STATE.winners.find((w) => w.isUser === true);
			                    if (existing) {
			                        existing.fullId = STATE.savedUserId;
			                        existing.displayId = STATE.savedUserId;
			                        existing.prizeKey = prizeKey;
			                        existing.prize = prizeDisplay;
			                        existing.ts = STATE.spinAt || Date.now();
			                        existing.isNew = false;
			                        renderWinners({
			                            preserveScroll: true
			                        });
			                    } else {
			                        pushWinnerEntry({
			                            id: makeEntryId("user"),
			                            isUser: true,
			                            fullId: STATE.savedUserId,
			                            displayId: STATE.savedUserId,
			                            prizeKey,
			                            prize: prizeDisplay,
			                            ts: STATE.spinAt || Date.now(),
			                            isNew: false,
			                        });
			                    }
			                }

			                if (!isModalOpen()) STATE.pauseReasons.delete("modal");
			            }

			            // =========================
			            // INIT (power-up lifecycle kecil, aman, modern)
			            // =========================
			            function init() {
			                detectLowEnd();
			                migrateLegacyKeys();
			                ensureEnhanceStyles();

			                STATE.hasSpun = lsGet(LS.HAS_SPUN, "false") === "true";
			                STATE.spinAt = Number(lsGet(LS.SPIN_AT, "0") || "0") || 0;
			                STATE.savedUserId = String(lsGet(LS.LAST_USER_ID, "") || "");
			                STATE.currentRotation = Number(lsGet(LS.ROTATION, "0") || "0") || 0;

			                STATE.pointerEl = $("pointerEl");

			                setupAudio();
			                drawWheelPrizes();
			                initWheelAutoResize();
			                initFxParticlesCanvas();

			                STATE.winners = generateMockWinnersRandom();
			                bootPersistedUserEntry();

			                applyWheelRotation(STATE.currentRotation);

			                renderWinners({
			                    preserveScroll: true
			                });
			                startMetaTickerOnce();
			                setupHistoryRowOpen();
			                setupWinnersScrollGuard();

			                STATE.jackpot = initJackpot();
			                startJackpot();
			                startLiveHistory();

			                updateUI();

			                // =========================
			                // LISTENERS
			                // =========================
			                const spinBtn = $("spinBtn");
			                const userIdInput = $("userIdInput");
			                const claimBtn = $("claimBtn");
			                const downloadBtn = $("downloadBtn");
			                const shareBtn = $("shareBtn");

			                if (userIdInput) {
			                    userIdInput.addEventListener("input", () => {
			                        userIdInput.value = normalizeUserIdInput(userIdInput.value);
			                    });
			                    userIdInput.addEventListener("keydown", (e) => {
			                        if (e.key === "Enter") {
			                            e.preventDefault();
			                            startSpin();
			                        }
			                    });
			                }

			                if (spinBtn) {
			                    spinBtn.addEventListener("click", startSpin);
			                    spinBtn.addEventListener("pointerdown", (e) => pressFX(spinBtn, e), {
			                        passive: true
			                    });
			                }

			                if (claimBtn) {
			                    claimBtn.addEventListener("click", claimPrize);
			                    claimBtn.addEventListener("pointerdown", (e) => pressFX(claimBtn, e), {
			                        passive: true
			                    });
			                }

			                if (downloadBtn) {
			                    downloadBtn.addEventListener("click", downloadResultPng);
			                    downloadBtn.addEventListener("pointerdown", (e) => pressFX(downloadBtn, e), {
			                        passive: true
			                    });
			                }

			                if (shareBtn) {
			                    shareBtn.addEventListener("click", shareUniversal);
			                    shareBtn.addEventListener("pointerdown", (e) => pressFX(shareBtn, e), {
			                        passive: true
			                    });
			                }

			                const prizeModal = $("prizeModal");
			                if (prizeModal) {
			                    prizeModal.addEventListener("click", (e) => {
			                        if (e.target && e.target.id === "prizeModal") closeModal();
			                    });
			                }

			                document.addEventListener("keydown", (e) => {
			                    if (e.key === "Escape") {
			                        if (isModalOpen()) closeModal();
			                        // kalau overlay klaim sedang tampil, ESC bisa “batal” secara aman
			                        if (isNavOpen()) hideNavLoading(true);
			                        return;
			                    }
			                    if (e.key === "Tab" && isModalOpen()) trapFocus(e);
			                });

			                // ✅ saat tab hidden: stop jackpot/history + stop spin driver + stop confetti
			                document.addEventListener("visibilitychange", () => {
			                    if (document.hidden) {
			                        stopCelebrate();
			                        stopLiveHistory();
			                        stopJackpot();
			                        stopSpinDriver(true);
			                    } else {
			                        startJackpot();
			                        if (STATE.pauseReasons.size === 0) startLiveHistory();
			                    }
			                });

			                const kick = () => kickAudio(true);
			                window.addEventListener("pointerdown", kick, {
			                    passive: true,
			                    once: true
			                });
			                window.addEventListener("keydown", kick, {
			                    passive: true,
			                    once: true
			                });

			                // BFCache hardening
			                window.addEventListener("pagehide", () => {
			                    stopCelebrate();
			                    clearClaimTimers();
			                });

			                window.addEventListener("pageshow", () => {
			                    hideNavLoading(true);
			                });

			                window.addEventListener("storage", (e) => {
			                    if (!e || !e.key) return;

			                    const prizeKeyLS = (LS && LS.LAST_PRIZE_KEY) ? LS.LAST_PRIZE_KEY : null;

			                    if (
			                        e.key === LS.HAS_SPUN ||
			                        e.key === LS.SPIN_AT ||
			                        e.key === LS.LAST_USER_ID ||
			                        e.key === LS.ROTATION ||
			                        (prizeKeyLS && e.key === prizeKeyLS)
			                    ) {
			                        STATE.hasSpun = lsGet(LS.HAS_SPUN, "false") === "true";
			                        STATE.spinAt = Number(lsGet(LS.SPIN_AT, "0") || "0") || 0;
			                        STATE.savedUserId = String(lsGet(LS.LAST_USER_ID, "") || "");
			                        STATE.currentRotation = Number(lsGet(LS.ROTATION, "0") || "0") || 0;

			                        bootPersistedUserEntry();
			                        applyWheelRotation(STATE.currentRotation);
			                        updateUI();
			                        renderWinners({
			                            preserveScroll: true
			                        });
			                    }

			                    if (e.key === LS.JACKPOT_VAL) {
			                        const v = Number(lsGet(LS.JACKPOT_VAL, "0") || "0") || 0;
			                        if (v > 1_000_000) {
			                            STATE.jackpot = v;
			                            const el = $("jackpot");
			                            const meta = $("jackpotMeta");
			                            if (el) el.textContent = `IDR ${Math.round(STATE.jackpot).toLocaleString("id-ID")}`;
			                            if (meta) meta.textContent = `Update: ${fmtClock()}`;
			                        }
			                    }
			                });
			            }

			            // =========================
			            // Kick init
			            // =========================
			            if (document.readyState === "loading") {
			                document.addEventListener("DOMContentLoaded", init, {
			                    once: true
			                });
			            } else {
			                init();
			            }

			        })();
		</script>
	</body>
</html>