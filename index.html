javascript:(() => {
  "use strict";

  try { if (window._s1panelKill) window._s1panelKill(); } catch (_) {}

  const META = { NAME: "Bubble LiveChat Bot", VERSION: "v6.6.0 FINAL" };
  const UI = { PANEL_ID: "s1-puck", STYLE_ID: "s1-style", CB_STYLE_ID: "s1-chatbar-style" };

  const CFG = {
    WRAP_SEL: ".react_meshim_dashboard_components_navBar_OldServeButton",
    READY_SPAN_SEL: "span[title]",
    RE_READY: /^\s*serve\s*1\s*request\s*$/i,
    RE_ZERO: /^\s*0\s*requests?\s*$/i,
    TOK_READY: ["serve","1","request"],
    TOK_ZERO: ["0","request"],
    CLICK_ON_ZERO: true,

    READY_COOLDOWN_MS: 22,
    ZERO_COOLDOWN_MS: 80,

    GLOBAL_COOLDOWN_MS: 8,
    GLOBAL_WINDOW_MS: 5000,
    GLOBAL_MAX_CLICKS_PER_WINDOW: 260,

    BURST_MS: 2200,
    HOT_BURST_FIRST_MS: 360,
    MO_BURST_THROTTLE_MS: 4,

    FALLBACK_POLL_MS: 55,
    MAX_SCAN: 30,
    IDLE_STOP_AFTER_FRAMES: 28,

    VERIFY_READY_DELAY_MS: 90,
    VERIFY_ZERO_DELAY_MS: 120,
    RETRY_READY_MAX: 3,
    RETRY_ZERO_MAX: 1,
    RETRY_BURST_MS: 260,

    USER_GRACE_ON_DOWN_MS: 650,
    USER_GRACE_AFTER_UP_MS: 90,
    USER_GRACE_ON_WHEEL_MS: 220,
    USER_GRACE_ON_KEY_MS: 280,

    CB_ITEM_SEL: ".meshim_dashboard_components_chatBar_Renderer.chat_bar_renderer",
    CB_UNREAD_SEL: ".unread_count",
    CB_DOTS_SEL: ".dots",
    CB_MSG_SEL: ".msg",
    CB_CLOSE_SEL: ".round_close_button",

    CB_LEAVE_CLASS: "leave",
    CB_LEAVE_TEXT_RE: /\bhas\s+left\b/i,
    CB_UNREAD_CLASS: "unread",

    CB_IGNORE_AGENT_ITEMS: true,
    CB_AGENT_CLASS: "agent",
    CB_AGENT_ROWID_PREFIX: "#agentchat:",

    CB_AUTO_OPEN_ON_UNREAD: true,
    CB_AUTO_OPEN_NEXT_UNREAD: true,
    CB_SKIP_LEAVE_ON_OPEN: true,

    CB_AUTO_CLOSE_LEAVE: true,
    CB_CLOSE_ONLY_IF_UNREAD_ZERO: true,
    CB_CLOSE_COOLDOWN_MS: 1200,
    CB_CLOSE_WINDOW_MS: 8000,
    CB_CLOSE_MAX_PER_WINDOW: 6,

    CB_IDLE_REQUIRED_MS: 60,
    CB_OPEN_COOLDOWN_MS: 160,
    CB_ITEM_OPEN_COOLDOWN_MS: 520,
    CB_POST_CLICK_LOCK_MS: 160,

    CB_OPEN_IGNORE_IDLE_ON_UNREAD: true,

    CB_SCAN_LIMIT: 240,
    CB_FAST_SCAN_MS: 95,
    CB_SLOW_SCAN_MS: 650,
    CB_IDLE_TO_SLOW_AFTER_MS: 2400,
    CB_FORCE_RESCAN_AFTER_MS: 4200,

    CB_CLICK_X_RATIO: 0.35,
    CB_CLICK_Y_RATIO: 0.55,

    CB_STRICT_TOPMOST_CHECK: false,

    TA_SEL: "textarea[data-test-id='chatTextArea'], textarea.meshim_dashboard_components_chatPanel_ChatTextAreaList.chat_input",
    TA_SHORTCUT_LIST_SEL: ".textfieldlist_list_container",
    TA_CLIPBOARD_IMG_SEL: ".meshim_dashboard_components_chatPanel_chatTextArea_ClipboardImage.clipboard_image",
  };

  let on = true;
  let GEN = 1;

  const wrapObserved = new WeakSet();
  const wrapLocalMO = new WeakMap();
  const lastState = new WeakMap();
  const armedReady = new WeakMap();
  const armedZero  = new WeakMap();
  const clickedAtReady = new WeakMap();
  const clickedAtZero  = new WeakMap();

  const readyAttempts = new WeakMap();
  const zeroAttempts  = new WeakMap();

  const ROOTS = new WeakSet();
  const rootMOs = [];
  const IFRS = new WeakSet();
  const shortcutBinds = [];

  const clickTimes = [];
  let clickHead = 0;
  let lastGlobalClickAt = 0;

  let burstUntil = 0;
  let burstHotUntil = 0;
  let hotTimer = 0;
  let rafId = 0;
  let pollTimer = 0;
  let lastMoBurstAt = 0;

  let userBusyUntil = 0;
  let userDown = false;
  let idleFrames = 0;
  let lastUserAt = 0;

  let pendingBurst = false;
  let wakeTimer = 0;

  const ORIG = {
    attachShadow: Element.prototype.attachShadow,
    pushState: history.pushState,
    replaceState: history.replaceState,
  };

  let onFocus = null, onVis = null, onPop = null;

  const now = () => (performance && performance.now ? performance.now() : Date.now());
  const norm = (t) => String(t || "").replace(/\s+/g, " ").trim();
  const safeAttr = (el, name) => { try { return el?.getAttribute?.(name) || ""; } catch (_) { return ""; } };

  const microtask = (fn) => {
    try {
      if (typeof queueMicrotask === "function") queueMicrotask(fn);
      else Promise.resolve().then(fn);
    } catch (_) { try { setTimeout(fn, 0); } catch (__) {} }
  };

  const markUserBusy = (ms) => {
    lastUserAt = now();
    const t = lastUserAt + ms;
    if (t > userBusyUntil) userBusyUntil = t;
  };

  const isDisabledish = (el) => {
    if (!el || el.nodeType !== 1) return true;
    if (el.disabled) return true;
    const ad = safeAttr(el, "aria-disabled");
    if (ad && ad.toLowerCase() === "true") return true;
    return false;
  };

  const isVisible = (el) => {
    try {
      if (!el || el.nodeType !== 1 || !el.isConnected) return false;
      if (isDisabledish(el)) return false;

      const w = el.ownerDocument?.defaultView || window;
      const cs = w.getComputedStyle(el);
      if (!cs) return false;
      if (cs.display === "none" || cs.visibility === "hidden") return false;
      if (cs.pointerEvents === "none") return false;
      if (+cs.opacity === 0) return false;

      const r = el.getBoundingClientRect();
      if (r.width <= 0 || r.height <= 0) return false;

      const vw = w.innerWidth || 0, vh = w.innerHeight || 0;
      const pad = 2;
      if (r.bottom < -pad || r.right < -pad || r.left > vw + pad || r.top > vh + pad) return false;

      return true;
    } catch (_) { return false; }
  };

  const elementFromPointOK = (el, x, y) => {
    try {
      const doc = el.ownerDocument || document;
      const top = doc.elementFromPoint(x, y);
      if (!top) return false;
      return (top === el) || el.contains(top);
    } catch (_) { return true; }
  };

  const textLooksLike = (text, tokens) => {
    const s = norm(text).toLowerCase();
    for (let i = 0; i < tokens.length; i++) if (!s.includes(tokens[i])) return false;
    return true;
  };

  const isComposerBusy = () => {
    try {
      const ae = document.activeElement;
      if (ae && ae.matches && ae.matches(CFG.TA_SEL)) return true;

      const list = document.querySelector?.(CFG.TA_SHORTCUT_LIST_SEL);
      if (list) {
        const cs = (list.ownerDocument?.defaultView || window).getComputedStyle(list);
        if (cs && cs.display !== "none" && cs.visibility !== "hidden") return true;
      }

      const clip = document.querySelector?.(CFG.TA_CLIPBOARD_IMG_SEL);
      if (clip) {
        const cs = (clip.ownerDocument?.defaultView || window).getComputedStyle(clip);
        if (cs && cs.display !== "none" && cs.visibility !== "hidden") return true;
      }

      return false;
    } catch (_) { return false; }
  };

  const canAct = () => {
    if (!on) return false;
    if (document.visibilityState && document.visibilityState !== "visible") return false;
    if (userDown) return false;
    if (isComposerBusy()) return false;
    return now() >= userBusyUntil;
  };

  const pruneClicks = (t) => {
    while (clickHead < clickTimes.length && (t - clickTimes[clickHead]) > CFG.GLOBAL_WINDOW_MS) clickHead++;
    if (clickHead > 96 && clickHead * 2 > clickTimes.length) {
      clickTimes.splice(0, clickHead);
      clickHead = 0;
    }
  };

  const globalThrottleOK = (t) => {
    pruneClicks(t);
    const live = clickTimes.length - clickHead;
    if (live >= CFG.GLOBAL_MAX_CLICKS_PER_WINDOW) return false;
    if ((t - lastGlobalClickAt) < CFG.GLOBAL_COOLDOWN_MS) return false;
    return true;
  };

  const getWrapState = (wrap) => {
    try {
      if (!wrap || wrap.nodeType !== 1) return "none";
      const sp = wrap.querySelector ? wrap.querySelector(CFG.READY_SPAN_SEL) : null;
      const a = norm(sp ? safeAttr(sp, "title") : "");
      const b = norm(sp ? (sp.textContent || "") : (wrap.textContent || ""));
      if (CFG.RE_READY.test(a) || CFG.RE_READY.test(b) || textLooksLike(a, CFG.TOK_READY) || textLooksLike(b, CFG.TOK_READY)) return "ready";
      if (CFG.RE_ZERO.test(a)  || CFG.RE_ZERO.test(b)  || textLooksLike(a, CFG.TOK_ZERO)  || textLooksLike(b, CFG.TOK_ZERO))  return "zero";
      return "none";
    } catch (_) { return "none"; }
  };

  const dispatchMouseLike = (el, type, o) => {
    try {
      const w = el.ownerDocument?.defaultView || window;
      const Ctor =
        (type.startsWith("pointer") && w.PointerEvent) ? w.PointerEvent :
        (w.MouseEvent ? w.MouseEvent : MouseEvent);
      el.dispatchEvent(new Ctor(type, o));
      return true;
    } catch (_) {
      try { el.dispatchEvent(new MouseEvent(type, o)); return true; }
      catch (__) { return false; }
    }
  };

  const fireSequence = (target) => {
    try {
      const w = target.ownerDocument?.defaultView || window;
      const pt = ("ontouchstart" in w) ? "touch" : "mouse";
      const r = target.getBoundingClientRect();
      const cx = r.left + r.width / 2;
      const cy = r.top + r.height / 2;

      const base = { bubbles:true, cancelable:true, view:w, clientX:cx, clientY:cy, composed:true };
      const down = { ...base, button:0, buttons:1 };
      const up   = { ...base, button:0, buttons:0 };

      dispatchMouseLike(target, "pointerover",  { ...base, pointerType:pt, isPrimary:true, pointerId:1 });
      dispatchMouseLike(target, "pointerenter", { ...base, pointerType:pt, isPrimary:true, pointerId:1 });
      dispatchMouseLike(target, "mouseover", base);
      dispatchMouseLike(target, "pointerdown", { ...down, pointerType:pt, isPrimary:true, pointerId:1 });
      dispatchMouseLike(target, "mousedown", down);
      dispatchMouseLike(target, "pointerup", { ...up, pointerType:pt, isPrimary:true, pointerId:1 });
      dispatchMouseLike(target, "mouseup", up);
      dispatchMouseLike(target, "click", { ...base, button:0 });
      try { target.click(); } catch (_) {}
      return true;
    } catch (_) {
      try { target.click(); return true; } catch (__) { return false; }
    }
  };

  const resetAttempts = (wrap, st) => {
    try {
      if (st === "ready") readyAttempts.set(wrap, 0);
      else if (st === "zero") zeroAttempts.set(wrap, 0);
    } catch (_) {}
  };

  const clearAttempts = (wrap, st) => {
    try {
      if (st === "ready") readyAttempts.delete(wrap);
      else if (st === "zero") zeroAttempts.delete(wrap);
    } catch (_) {}
  };

  const bumpAttempt = (wrap, st) => {
    try {
      if (st === "ready") readyAttempts.set(wrap, (readyAttempts.get(wrap) || 0) + 1);
      else if (st === "zero") zeroAttempts.set(wrap, (zeroAttempts.get(wrap) || 0) + 1);
    } catch (_) {}
  };

  const getAttempt = (wrap, st) => {
    try {
      if (st === "ready") return (readyAttempts.get(wrap) || 0);
      if (st === "zero") return (zeroAttempts.get(wrap) || 0);
      return 0;
    } catch (_) { return 0; }
  };

  const rearmIfNeeded = (wrap, st) => {
    const prev = lastState.get(wrap) || "none";

    if (st !== prev) {
      if (prev === "ready" && st !== "ready") { armedReady.set(wrap, true); clearAttempts(wrap, "ready"); }
      if (prev === "zero"  && st !== "zero")  { armedZero.set(wrap, true);  clearAttempts(wrap, "zero"); }

      if (st === "ready") resetAttempts(wrap, "ready");
      if (st === "zero")  resetAttempts(wrap, "zero");

      if (st === "none") {
        armedReady.set(wrap, true);
        armedZero.set(wrap, true);
        clearAttempts(wrap, "ready");
        clearAttempts(wrap, "zero");
      }

      lastState.set(wrap, st);
    } else {
      if (!armedReady.has(wrap)) armedReady.set(wrap, true);
      if (!armedZero.has(wrap))  armedZero.set(wrap, true);
      if (st === "ready" && !readyAttempts.has(wrap)) resetAttempts(wrap, "ready");
      if (st === "zero"  && !zeroAttempts.has(wrap))  resetAttempts(wrap, "zero");
    }
  };

  const postClickVerify = (wrap, st, g) => {
    const delay = (st === "ready") ? CFG.VERIFY_READY_DELAY_MS : CFG.VERIFY_ZERO_DELAY_MS;
    setTimeout(() => {
      try {
        if (!on || g !== GEN) return;
        if (!wrap || wrap.nodeType !== 1 || !wrap.isConnected) return;

        const cur = getWrapState(wrap);
        if (cur !== st) return;

        const attempts = getAttempt(wrap, st);
        const max = (st === "ready") ? CFG.RETRY_READY_MAX : CFG.RETRY_ZERO_MAX;
        if (attempts >= max) return;

        if (st === "ready") armedReady.set(wrap, true);
        if (st === "zero")  armedZero.set(wrap, true);

        scheduleBurst(CFG.RETRY_BURST_MS);
      } catch (_) {}
    }, delay);
  };

  const smartClick = (wrap, st) => {
    if (!canAct()) return false;
    if (!wrap || wrap.nodeType !== 1) return false;
    if (!isVisible(wrap)) return false;

    st = st || getWrapState(wrap);
    if (st === "none") return false;
    if (st === "zero" && !CFG.CLICK_ON_ZERO) return false;

    if (st === "ready" && armedReady.get(wrap) === false) return false;
    if (st === "zero"  && armedZero.get(wrap)  === false) return false;

    const t = now();
    if (!globalThrottleOK(t)) return false;

    const map = (st === "ready") ? clickedAtReady : clickedAtZero;
    const cd  = (st === "ready") ? CFG.READY_COOLDOWN_MS : CFG.ZERO_COOLDOWN_MS;
    const prev = map.get(wrap) || 0;
    if ((t - prev) < cd) return false;

    map.set(wrap, t);
    clickTimes.push(t);
    lastGlobalClickAt = t;

    if (st === "ready") armedReady.set(wrap, false);
    if (st === "zero")  armedZero.set(wrap, false);

    bumpAttempt(wrap, st);

    fireSequence(wrap);

    try {
      const sp = wrap.querySelector?.(CFG.READY_SPAN_SEL);
      if (sp && sp !== wrap && isVisible(sp)) { try { sp.click(); } catch (_) {} }
    } catch (_) {}

    postClickVerify(wrap, st, GEN);
    return true;
  };

  const attachWrapLocalObserver = (wrap) => {
    if (!wrap || wrap.nodeType !== 1) return;
    if (wrapLocalMO.has(wrap)) return;

    const mo = new MutationObserver(() => {
      try {
        if (!on) return;

        if (!wrap.isConnected) {
          try { mo.disconnect(); } catch (_) {}
          try { wrapLocalMO.delete(wrap); } catch (_) {}
          return;
        }

        const t = now();
        if ((t - lastMoBurstAt) < CFG.MO_BURST_THROTTLE_MS) return;
        lastMoBurstAt = t;

        const st = getWrapState(wrap);
        rearmIfNeeded(wrap, st);
        if (st !== "none") smartClick(wrap, st);

        scheduleBurst();
      } catch (_) {}
    });

    try {
      mo.observe(wrap, {
        subtree: true,
        childList: true,
        characterData: true,
        attributes: true,
        attributeFilter: ["title","class","style","hidden","aria-hidden","aria-disabled","disabled","role"]
      });
    } catch (_) {}

    wrapLocalMO.set(wrap, mo);
  };

  const registerWrap = (wrap, stOpt) => {
    if (!wrap || wrap.nodeType !== 1) return { st: "none", clicked: false };

    if (!wrapObserved.has(wrap)) {
      wrapObserved.add(wrap);
      attachWrapLocalObserver(wrap);
    }

    let st = stOpt;
    try { st = st || getWrapState(wrap); } catch (_) { st = "none"; }

    try { rearmIfNeeded(wrap, st); } catch (_) {}
    let clicked = false;
    try { if (st !== "none") clicked = smartClick(wrap, st); } catch (_) {}

    return { st, clicked };
  };

  const scanAndRegister = () => {
    if (!canAct()) return { found:false, clicked:false };

    let wraps = [];
    try { wraps = document.querySelectorAll ? document.querySelectorAll(CFG.WRAP_SEL) : []; } catch (_) { wraps = []; }
    if (!wraps || !wraps.length) return { found:false, clicked:false };

    let found = false;
    let clicked = false;

    const n = Math.min(wraps.length, CFG.MAX_SCAN);
    for (let i = 0; i < n; i++) {
      const w = wraps[i];
      const st = getWrapState(w);
      const r = registerWrap(w, st);
      if (r.st !== "none") found = true;
      if (r.clicked) clicked = true;
    }

    return { found, clicked };
  };

  const hotTick = (g) => {
    if (!on || g !== GEN) { hotTimer = 0; return; }
    if (userDown || isComposerBusy()) { hotTimer = 0; return; }

    const t = now();
    if (t > burstUntil) { hotTimer = 0; return; }

    const r = scanAndRegister();
    if (!r.found && !r.clicked) idleFrames++; else idleFrames = 0;
    if (idleFrames >= CFG.IDLE_STOP_AFTER_FRAMES) { hotTimer = 0; return; }

    if (t < burstHotUntil) hotTimer = setTimeout(() => hotTick(g), 0);
    else hotTimer = 0;
  };

  const rafTick = (g) => {
    if (!on || g !== GEN) { rafId = 0; return; }
    if (userDown || isComposerBusy()) { rafId = 0; return; }

    const t = now();
    if (t > burstUntil) { rafId = 0; return; }

    const r = scanAndRegister();
    if (!r.found && !r.clicked) idleFrames++; else idleFrames = 0;
    if (idleFrames >= CFG.IDLE_STOP_AFTER_FRAMES) { rafId = 0; return; }

    rafId = requestAnimationFrame(() => rafTick(g));
  };

  function wakeIfNeeded() {
    if (wakeTimer) return;
    wakeTimer = setTimeout(() => {
      wakeTimer = 0;
      if (!on) return;
      if (userDown || isComposerBusy() || now() < userBusyUntil) { wakeIfNeeded(); return; }
      if (pendingBurst) {
        pendingBurst = false;
        scheduleBurst(400);
      }
    }, 120);
  }

  function scheduleBurst(ms = CFG.BURST_MS) {
    if (!on) return;

    const t = now();
    burstUntil = Math.max(burstUntil, t + ms);
    burstHotUntil = Math.max(burstHotUntil, t + CFG.HOT_BURST_FIRST_MS);

    if (userDown || isComposerBusy() || t < userBusyUntil) {
      pendingBurst = true;
      wakeIfNeeded();
      return;
    }

    const g = GEN;

    try { scanAndRegister(); } catch (_) {}

    if (!hotTimer) hotTimer = setTimeout(() => hotTick(g), 0);
    if (!rafId && typeof requestAnimationFrame === "function") rafId = requestAnimationFrame(() => rafTick(g));
  }

  const wireRoot = (root) => {
    try {
      if (!root || ROOTS.has(root)) return;
      ROOTS.add(root);

      const mo = new MutationObserver((records) => {
        if (!on) return;

        let hit = false;
        for (let i = 0; i < records.length; i++) {
          const m = records[i];
          if (!m) continue;

          if (m.type === "childList") {
            const nodes = m.addedNodes;
            if (nodes && nodes.length) {
              for (let j = 0; j < nodes.length; j++) {
                const n = nodes[j];
                if (!n || n.nodeType !== 1) continue;
                try {
                  if (n.matches && n.matches(CFG.WRAP_SEL)) { registerWrap(n); hit = true; }
                  const q = n.querySelectorAll ? n.querySelectorAll(CFG.WRAP_SEL) : null;
                  if (q && q.length) { q.forEach(registerWrap); hit = true; }
                } catch (_) {}
              }
            }
          }

          if (m.type === "attributes") {
            const tt = (m.target && m.target.nodeType === 1) ? m.target : m.target?.parentElement;
            if (!tt) continue;
            try {
              const w = tt.matches?.(CFG.WRAP_SEL) ? tt : tt.closest?.(CFG.WRAP_SEL);
              if (w) { registerWrap(w); hit = true; }
            } catch (_) {}
          }
        }

        if (hit) scheduleBurst();
      });

      mo.observe(root, {
        subtree: true,
        childList: true,
        attributes: true,
        attributeFilter: ["title","class","style","hidden","aria-hidden","aria-disabled","disabled","role"]
      });

      rootMOs.push(mo);
      scheduleBurst(900);
    } catch (_) {}
  };

  const wireFrame = (f) => {
    try {
      if (!f || f.nodeName !== "IFRAME" || IFRS.has(f)) return;
      IFRS.add(f);

      const bind = () => {
        try {
          if (!on) return;
          const d = f.contentDocument;
          const w = f.contentWindow;
          if (d) wireRoot(d);
          if (w) bindShortcut(w);
          scheduleBurst(900);
          cbKick("frame");
        } catch (_) {}
      };

      f.addEventListener("load", bind, { passive: true });
      bind();
    } catch (_) {}
  };

  const bindShortcut = (w) => {
    try {
      if (!w) return;
      for (let i = 0; i < shortcutBinds.length; i++) if (shortcutBinds[i].w === w) return;

      let last = 0;
      const h = (e) => {
        try {
          const k = e.key || "";
          const isEnter = (k === "Enter" || k === "NumpadEnter" || e.keyCode === 13);
          if (!(e.ctrlKey || e.metaKey) || !isEnter) return;
          const t = now();
          if ((t - last) < 160) return;
          last = t;
          toggle();
        } catch (_) {}
      };

      w.addEventListener("keydown", h, { capture: true });
      shortcutBinds.push({ w, h });
    } catch (_) {}
  };

  const unbindShortcuts = () => {
    for (let i = 0; i < shortcutBinds.length; i++) {
      const { w, h } = shortcutBinds[i];
      try { w.removeEventListener("keydown", h, { capture: true }); } catch (_) {}
    }
    shortcutBinds.length = 0;
  };

  /* =========================
   * UI (PUCK) - FINAL SMOOTH TOUCH (rAF + translate3d)
   * ======================= */
  const POS_KEY = "s1_puck_pos_v1";

  const updateUI = () => {
    const d = document.getElementById(UI.PANEL_ID);
    if (!d) return;
    d.classList.toggle("off", !on);
    d.title = `${META.NAME} ${META.VERSION} - ${on ? "Active" : "Off"}\nCtrl+Enter : Toggle\nShift+Tap bubble : Remove`;
  };

  const buildUI = () => {
    if (!document.getElementById(UI.STYLE_ID)) {
      const s = document.createElement("style");
      s.id = UI.STYLE_ID;
      s.textContent = `
#${UI.PANEL_ID}{
  position:fixed; z-index:2147483647;
  left:0; top:0; right:auto; bottom:auto;
  width:42px; height:42px;
  display:inline-flex; align-items:center; justify-content:center;
  border-radius:9999px; cursor:pointer;
  box-shadow: 0 10px 26px rgba(0,0,0,.34),
              inset 0 1px 0 rgba(255,255,255,.12),
              inset 0 -1px 0 rgba(0,0,0,.22);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  transition: opacity .16s ease, transform .05s linear;
  background: linear-gradient(145deg, rgba(36,36,36,.90), rgba(10,10,10,.72));
  touch-action:none;
  -webkit-user-select:none; user-select:none;
  -webkit-tap-highlight-color: transparent;
  will-change: transform;
  contain: layout paint style;
}
#${UI.PANEL_ID}.off{ opacity:.45; }
#${UI.PANEL_ID}:active{ filter: brightness(1.03); }
#${UI.PANEL_ID} .logo{ width:24px; height:24px; pointer-events:none; filter: drop-shadow(0 1px 2px rgba(0,0,0,.3)); }
@media (prefers-color-scheme: light){
  #${UI.PANEL_ID}{ background: linear-gradient(145deg, rgba(255,255,255,.95), rgba(240,240,240,.80)); }
}`.trim();
      (document.head || document.documentElement).appendChild(s);
    }

    let d = document.getElementById(UI.PANEL_ID);
    if (!d) {
      d = document.createElement("div");
      d.id = UI.PANEL_ID;

      const NS = "http://www.w3.org/2000/svg";
      const svg = document.createElementNS(NS, "svg");
      svg.setAttribute("viewBox", "0 -30.5 256 256");
      svg.setAttribute("class", "logo");
      svg.setAttribute("preserveAspectRatio", "xMidYMid");
      const g = document.createElementNS(NS, "g");
      const p = document.createElementNS(NS, "path");
      p.setAttribute("d",
        "M118.249172,51.2326115 L118.249172,194.005605 L0,194.005605 L118.249172,51.2326115 Z "+
        "M118.249172,0 C118.249172,32.6440764 91.7686624,59.124586 59.124586,59.124586 "+
        "C26.4805096,59.124586 0,32.6440764 0,0 L118.249172,0 Z "+
        "M137.750828,194.005605 C137.750828,161.328917 164.198726,134.881019 196.875414,134.881019 "+
        "C229.552102,134.881019 256,161.361529 256,194.005605 L137.750828,194.005605 Z "+
        "M137.750828,142.740382 L137.750828,0 L256,0 L137.750828,142.740382 Z"
      );
      p.setAttribute("fill", "#03363D");
      g.appendChild(p);
      svg.appendChild(g);
      d.appendChild(svg);

      let x = 0, y = 0, w = 42, h = 42;
      let drag = false, moved = false;
      let startCX = 0, startCY = 0, startX = 0, startY = 0;
      let rafPos = 0, dirty = false;
      let capId = null;

      const clamp = (vx, vy) => {
        const vw = innerWidth || 0, vh = innerHeight || 0;
        const pad = 6;
        const cx = Math.min(Math.max(pad, vx), Math.max(pad, vw - w - pad));
        const cy = Math.min(Math.max(pad, vy), Math.max(pad, vh - h - pad));
        return [cx, cy];
      };

      const applyPos = () => {
        rafPos = 0;
        if (!dirty) return;
        dirty = false;
        d.style.transform = `translate3d(${x}px,${y}px,0)`;
      };

      const setPos = (vx, vy) => {
        const c = clamp(vx, vy);
        x = c[0]; y = c[1];
        dirty = true;
        if (!rafPos) rafPos = requestAnimationFrame(applyPos);
      };

      const loadPos = () => {
        try {
          const raw = localStorage.getItem(POS_KEY);
          if (raw) {
            const j = JSON.parse(raw);
            if (j && Number.isFinite(j.x) && Number.isFinite(j.y)) {
              x = j.x; y = j.y;
              dirty = true;
              applyPos();
              return;
            }
          }
        } catch (_) {}
        x = Math.max(6, (innerWidth || 0) - 14 - 42);
        y = Math.max(6, (innerHeight || 0) - 14 - 42);
        dirty = true;
        applyPos();
      };

      const savePos = () => {
        try { localStorage.setItem(POS_KEY, JSON.stringify({ x, y })); } catch (_) {}
      };

      const refreshSize = () => {
        try {
          const r = d.getBoundingClientRect();
          if (r && r.width > 0 && r.height > 0) { w = r.width; h = r.height; }
        } catch (_) {}
      };

      loadPos();
      refreshSize();

      const onResize = () => { refreshSize(); setPos(x, y); };
      addEventListener("resize", onResize, { passive: true });

      d.onpointerdown = (e) => {
        try {
          drag = true; moved = false;
          refreshSize();
          startCX = e.clientX; startCY = e.clientY;
          startX = x; startY = y;
          capId = e.pointerId;
          try { d.setPointerCapture(e.pointerId); } catch (_) {}
          if (e.cancelable) { try { e.preventDefault(); } catch (_) {} }
        } catch (_) {}
      };

      d.onpointermove = (e) => {
        if (!drag) return;
        try {
          const dx = e.clientX - startCX;
          const dy = e.clientY - startCY;
          if (Math.abs(dx) + Math.abs(dy) > 4) moved = true;
          setPos(startX + dx, startY + dy);
          if (e.cancelable) { try { e.preventDefault(); } catch (_) {} }
        } catch (_) {}
      };

      const endDrag = () => {
        drag = false;
        try { if (capId != null) d.releasePointerCapture(capId); } catch (_) {}
        capId = null;
        savePos();
      };

      d.onpointerup = endDrag;
      d.onpointercancel = endDrag;
      d.onlostpointercapture = endDrag;

      d.onclick = (e) => {
        if (moved) { moved = false; return; }
        if (e && e.shiftKey) { kill(); return; }
        toggle();
      };

      (document.body || document.documentElement).appendChild(d);
    }

    updateUI();
  };

  /* =========================
   * CHATBAR ENGINE (light pause while touching)
   * ======================= */
  const cbState = new WeakMap();
  let cbRootMO = null;

  let cbScanTimer = 0;
  let cbLastMutAt = 0;
  let cbLastScanAt = 0;
  let cbLastOpenAt = 0;

  const cbCloseTimes = [];
  let cbCloseHead = 0;
  let cbLastCloseAt = 0;

  const cbPendingOpen = new WeakMap();
  const cbPostClickLockUntil = new WeakMap();

  const cbQS = (root, sel) => { try { return root?.querySelector?.(sel) || null; } catch (_) { return null; } };
  const cbQSA = (root, sel) => { try { return root?.querySelectorAll?.(sel) || []; } catch (_) { return []; } };

  const cbParseUnread = (s) => {
    const m = String(s || "").match(/\d+/);
    if (!m) return 0;
    const n = parseInt(m[0], 10);
    return Number.isFinite(n) ? n : 0;
  };

  const cbIsAgentItem = (item) => {
    try {
      if (!CFG.CB_IGNORE_AGENT_ITEMS) return false;
      if (!item || item.nodeType !== 1) return false;
      if (item.classList?.contains(CFG.CB_AGENT_CLASS)) return true;

      const rowid = safeAttr(item, "jx:list:rowid") || safeAttr(item, "jx:list:rowId") || safeAttr(item, "data-rowid");
      if (rowid && String(rowid).toLowerCase().startsWith(String(CFG.CB_AGENT_ROWID_PREFIX).toLowerCase())) return true;
      return false;
    } catch (_) { return false; }
  };

  const cbGetUnread = (item) => {
    const el = cbQS(item, CFG.CB_UNREAD_SEL);
    if (el) return cbParseUnread(el.textContent);
    try { if (item.classList?.contains(CFG.CB_UNREAD_CLASS)) return 1; } catch (_) {}
    return 0;
  };

  const cbGetLoading = (item) => {
    const el = cbQS(item, CFG.CB_DOTS_SEL);
    if (!el) return false;
    try {
      const w = el.ownerDocument?.defaultView || window;
      const cs = w.getComputedStyle(el);
      if (!cs) return false;
      if (cs.display === "none") return false;
      if (cs.visibility === "hidden") return false;
      if (+cs.opacity === 0) return false;
      return true;
    } catch (_) {
      const st = (el.getAttribute("style") || "").toLowerCase();
      return st.includes("visibility: visible") || st.includes("visibility:visible");
    }
  };

  const cbGetActive = (item) => {
    try {
      if (item.classList?.contains("active")) return true;
      const aria = safeAttr(item, "aria-selected");
      if (aria && aria.toLowerCase() === "true") return true;
      return false;
    } catch (_) { return false; }
  };

  const cbGetLeave = (item) => {
    try {
      if (item.classList?.contains(CFG.CB_LEAVE_CLASS)) return true;
      const msg = cbQS(item, CFG.CB_MSG_SEL);
      const t = norm(msg ? msg.textContent : "");
      return !!(t && CFG.CB_LEAVE_TEXT_RE.test(t));
    } catch (_) { return false; }
  };

  const cbCanOpen = (reason) => {
    if (!on) return false;
    if (document.visibilityState && document.visibilityState !== "visible") return false;
    if (userDown) return false;
    if (isComposerBusy()) return false;
    if (reason === "unread" && CFG.CB_OPEN_IGNORE_IDLE_ON_UNREAD) return true;
    return (now() - lastUserAt) >= CFG.CB_IDLE_REQUIRED_MS;
  };

  const cbEnsureInView = (el) => {
    try {
      if (!el || !el.isConnected) return;
      const r = el.getBoundingClientRect();
      const w = el.ownerDocument?.defaultView || window;
      const vh = w.innerHeight || 0;
      if (r.top < 0 || r.bottom > vh) {
        try { el.scrollIntoView({ block: "nearest", inline: "nearest" }); } catch (_) {}
      }
    } catch (_) {}
  };

  const cbTopmostOK = (item) => {
    if (!CFG.CB_STRICT_TOPMOST_CHECK) return true;
    try {
      const doc = item.ownerDocument || document;
      const w = doc.defaultView || window;
      const r = item.getBoundingClientRect();
      const cx = r.left + r.width * CFG.CB_CLICK_X_RATIO;
      const cy = r.top + r.height * CFG.CB_CLICK_Y_RATIO;
      const vw = w.innerWidth || 0, vh = w.innerHeight || 0;
      if (!(cx >= 0 && cy >= 0 && cx <= vw && cy <= vh)) return false;
      return elementFromPointOK(item, cx, cy);
    } catch (_) { return true; }
  };

  const cbFireItemClick = (item) => {
    try {
      if (!item) return false;

      const w = item.ownerDocument?.defaultView || window;
      const pt = ("ontouchstart" in w) ? "touch" : "mouse";
      const r = item.getBoundingClientRect();
      const cx = r.left + r.width * CFG.CB_CLICK_X_RATIO;
      const cy = r.top + r.height * CFG.CB_CLICK_Y_RATIO;

      const base = { bubbles:true, cancelable:true, view:w, clientX:cx, clientY:cy, composed:true };
      const down = { ...base, button:0, buttons:1 };
      const up   = { ...base, button:0, buttons:0 };

      dispatchMouseLike(item, "pointerover",  { ...base, pointerType:pt, isPrimary:true, pointerId:2 });
      dispatchMouseLike(item, "pointerdown",  { ...down, pointerType:pt, isPrimary:true, pointerId:2 });
      dispatchMouseLike(item, "mousedown", down);
      dispatchMouseLike(item, "pointerup",    { ...up, pointerType:pt, isPrimary:true, pointerId:2 });
      dispatchMouseLike(item, "mouseup", up);
      dispatchMouseLike(item, "click", { ...base, button:0 });
      try { item.click(); } catch (_) {}
      return true;
    } catch (_) {
      try { item.click(); return true; } catch (__) { return false; }
    }
  };

  const cbPruneCloses = (t) => {
    while (cbCloseHead < cbCloseTimes.length && (t - cbCloseTimes[cbCloseHead]) > CFG.CB_CLOSE_WINDOW_MS) cbCloseHead++;
    if (cbCloseHead > 24 && cbCloseHead * 2 > cbCloseTimes.length) {
      cbCloseTimes.splice(0, cbCloseHead);
      cbCloseHead = 0;
    }
  };

  const cbCloseThrottleOK = (t) => {
    cbPruneCloses(t);
    const live = cbCloseTimes.length - cbCloseHead;
    if (live >= CFG.CB_CLOSE_MAX_PER_WINDOW) return false;
    if ((t - cbLastCloseAt) < CFG.CB_CLOSE_COOLDOWN_MS) return false;
    return true;
  };

  const cbOpenThrottleOK = (t) => {
    if ((t - cbLastOpenAt) < CFG.CB_OPEN_COOLDOWN_MS) return false;
    return true;
  };

  const cbScheduleOpen = (item, reason) => {
    try {
      const t = now();
      const p = cbPendingOpen.get(item) || 0;
      if ((t - p) < 25) return;
      cbPendingOpen.set(item, t);

      microtask(() => {
        try { cbOpenIfAllowed(item, reason); } catch (_) {}
      });
    } catch (_) {}
  };

  const cbOpenIfAllowed = (item, reason) => {
    if (reason === "unread" && !CFG.CB_AUTO_OPEN_ON_UNREAD) return false;
    if (reason === "next" && !CFG.CB_AUTO_OPEN_NEXT_UNREAD) return false;

    if (!cbCanOpen(reason)) return false;
    if (!item || item.nodeType !== 1) return false;
    if (!isVisible(item)) return false;

    if (cbIsAgentItem(item)) return false;

    const s = cbState.get(item);
    if (!s) return false;

    if (CFG.CB_SKIP_LEAVE_ON_OPEN && s.leave) return false;
    if (s.loading) return false;
    if (s.active) return false;

    const t = now();
    if (!cbOpenThrottleOK(t)) return false;

    const lockUntil = cbPostClickLockUntil.get(item) || 0;
    if (t < lockUntil) return false;

    if ((t - (s.lastOpenAt || 0)) < CFG.CB_ITEM_OPEN_COOLDOWN_MS) return false;

    cbEnsureInView(item);
    if (!cbTopmostOK(item)) return false;

    cbLastOpenAt = t;
    s.lastOpenAt = t;
    cbState.set(item, s);

    const ok = cbFireItemClick(item);
    cbPostClickLockUntil.set(item, t + CFG.CB_POST_CLICK_LOCK_MS);
    return ok;
  };

  const cbCloseIfAllowed = (item) => {
    if (!CFG.CB_AUTO_CLOSE_LEAVE) return false;
    if (!item || item.nodeType !== 1) return false;
    if (!isVisible(item)) return false;

    if (cbIsAgentItem(item)) return false;

    const s = cbState.get(item);
    if (!s) return false;

    if (!s.leave) return false;
    if (s.loading) return false;
    if (s.active) return false;
    if (CFG.CB_CLOSE_ONLY_IF_UNREAD_ZERO && s.unread > 0) return false;

    const t = now();
    if (!cbCloseThrottleOK(t)) return false;
    if ((t - (s.lastCloseAt || 0)) < CFG.CB_CLOSE_COOLDOWN_MS) return false;

    const closeBtn = cbQS(item, CFG.CB_CLOSE_SEL);
    if (!closeBtn) return false;

    cbEnsureInView(closeBtn);

    cbLastCloseAt = t;
    cbCloseTimes.push(t);

    s.lastCloseAt = t;
    cbState.set(item, s);

    try { closeBtn.click(); return true; }
    catch (_) {
      try { cbFireItemClick(closeBtn); return true; } catch (__) { return false; }
    }
  };

  const cbPickBestUnread = () => {
    const items = cbQSA(document, CFG.CB_ITEM_SEL);
    let best = null;
    let bestN = -1;

    const n = Math.min(items.length, CFG.CB_SCAN_LIMIT);
    for (let i = 0; i < n; i++) {
      const it = items[i];
      if (!it || it.nodeType !== 1) continue;

      if (cbIsAgentItem(it)) continue;

      const s = cbState.get(it);
      const unread = s ? s.unread : cbGetUnread(it);
      if (unread <= 0) continue;

      const loading = s ? s.loading : cbGetLoading(it);
      const active  = s ? s.active  : cbGetActive(it);
      const leave   = s ? s.leave   : cbGetLeave(it);

      if (loading || active) continue;
      if (CFG.CB_SKIP_LEAVE_ON_OPEN && leave) continue;

      if (unread > bestN) { bestN = unread; best = it; }
    }

    return best;
  };

  const cbEvalItem = (item) => {
    try {
      if (!item || item.nodeType !== 1) return;

      const isAgent = cbIsAgentItem(item);

      const prev = cbState.get(item) || {
        unread: 0, loading: false, active: false, leave: false,
        lastOpenAt: 0, lastCloseAt: 0, isAgent: false
      };

      const unread = cbGetUnread(item);
      const loading = cbGetLoading(item);
      const active = cbGetActive(item);
      const leave = cbGetLeave(item);

      const unreadUp = unread > prev.unread;
      const becameUnread = prev.unread === 0 && unread > 0;
      const leaveUp = !prev.leave && leave;

      const next = { ...prev, unread, loading, active, leave, isAgent };
      cbState.set(item, next);

      if (isAgent) return;

      if (CFG.CB_AUTO_OPEN_ON_UNREAD && (becameUnread || unreadUp)) {
        if (!(CFG.CB_SKIP_LEAVE_ON_OPEN && leave)) cbScheduleOpen(item, "unread");
      }

      if (CFG.CB_AUTO_OPEN_NEXT_UNREAD) {
        const readyToAdvance =
          (active && unread === 0) ||
          (prev.unread > 0 && unread === 0);

        if (readyToAdvance && cbCanOpen("next")) {
          const nx = cbPickBestUnread();
          if (nx) cbScheduleOpen(nx, "next");
        }
      }

      if (CFG.CB_AUTO_CLOSE_LEAVE && (leaveUp || (leave && unread === 0 && !active))) {
        cbCloseIfAllowed(item);
      }

      if (unread > 0 || loading || (leave && CFG.CB_AUTO_CLOSE_LEAVE)) cbKick("hot");
    } catch (_) {}
  };

  const cbScanAll = () => {
    try {
      const items = cbQSA(document, CFG.CB_ITEM_SEL);
      const n = Math.min(items.length, CFG.CB_SCAN_LIMIT);
      for (let i = 0; i < n; i++) cbEvalItem(items[i]);
    } catch (_) {}
  };

  const cbHasWork = () => {
    try {
      const items = cbQSA(document, CFG.CB_ITEM_SEL);
      const n = Math.min(items.length, 80);
      for (let i = 0; i < n; i++) {
        const it = items[i];
        if (!it) continue;
        if (cbIsAgentItem(it)) continue;
        const unread = cbGetUnread(it);
        if (unread > 0) return true;
      }
      return false;
    } catch (_) { return true; }
  };

  const cbPlanNextScan = () => {
    try {
      if (!on) return;
      if (cbScanTimer) return;

      if (userDown || isComposerBusy()) {
        cbScanTimer = setTimeout(() => { cbScanTimer = 0; cbPlanNextScan(); }, 250);
        return;
      }

      const t = now();
      const quietFor = t - cbLastMutAt;
      const sinceScan = t - cbLastScanAt;

      const hasWork = cbHasWork();
      const fast = hasWork || quietFor < CFG.CB_IDLE_TO_SLOW_AFTER_MS;

      let ms = fast ? CFG.CB_FAST_SCAN_MS : CFG.CB_SLOW_SCAN_MS;
      if (sinceScan > CFG.CB_FORCE_RESCAN_AFTER_MS) ms = Math.min(ms, CFG.CB_FAST_SCAN_MS);

      cbScanTimer = setTimeout(() => {
        cbScanTimer = 0;
        if (!on) return;
        if (userDown || isComposerBusy()) { cbPlanNextScan(); return; }
        cbLastScanAt = now();
        cbScanAll();
        cbPlanNextScan();
      }, ms);
    } catch (_) {}
  };

  const cbKick = () => {
    try {
      if (!on) return;
      cbLastMutAt = now();
      microtask(() => {
        try {
          if (!on) return;
          if (userDown || isComposerBusy()) return;
          if (CFG.CB_AUTO_OPEN_NEXT_UNREAD && cbCanOpen("next")) {
            const nx = cbPickBestUnread();
            if (nx) cbScheduleOpen(nx, "next");
          }
        } catch (_) {}
      });
      cbPlanNextScan();
    } catch (_) {}
  };

  const cbWire = () => {
    if (cbRootMO) return;

    if (!document.getElementById(UI.CB_STYLE_ID)) {
      const s = document.createElement("style");
      s.id = UI.CB_STYLE_ID;
      s.textContent = `
${CFG.CB_ITEM_SEL}{ transition: filter .12s ease; }
${CFG.CB_ITEM_SEL}.${CFG.CB_LEAVE_CLASS}{ filter: grayscale(.25) contrast(0.95); }
`.trim();
      (document.head || document.documentElement).appendChild(s);
    }

    cbRootMO = new MutationObserver((recs) => {
      if (!on) return;
      cbLastMutAt = now();

      const touched = new Set();
      try {
        for (let i = 0; i < recs.length; i++) {
          const m = recs[i];
          if (!m) continue;

          if (m.type === "childList") {
            const a = m.addedNodes;
            if (a && a.length) {
              for (let j = 0; j < a.length; j++) {
                const n = a[j];
                if (!n || n.nodeType !== 1) continue;
                const it = n.matches?.(CFG.CB_ITEM_SEL) ? n : n.closest?.(CFG.CB_ITEM_SEL);
                if (it) touched.add(it);
                const q = n.querySelectorAll?.(CFG.CB_ITEM_SEL);
                if (q && q.length) q.forEach((x) => touched.add(x));
              }
            }
          } else {
            const tt = (m.target && m.target.nodeType === 1) ? m.target : m.target?.parentElement;
            if (!tt) continue;
            const it = tt.matches?.(CFG.CB_ITEM_SEL) ? tt : tt.closest?.(CFG.CB_ITEM_SEL);
            if (it) touched.add(it);
          }
        }
      } catch (_) {}

      if (touched.size) touched.forEach((it) => cbEvalItem(it));
      cbPlanNextScan();
    });

    try {
      cbRootMO.observe(document.body || document.documentElement, {
        subtree: true,
        childList: true,
        attributes: true,
        characterData: true
      });
    } catch (_) {}

    cbLastMutAt = now();
    cbLastScanAt = now();
    cbScanAll();
    cbPlanNextScan();
  };

  const cbUnwire = () => {
    try { if (cbRootMO) cbRootMO.disconnect(); } catch (_) {}
    cbRootMO = null;

    try { if (cbScanTimer) clearTimeout(cbScanTimer); } catch (_) {}
    cbScanTimer = 0;

    try { const s = document.getElementById(UI.CB_STYLE_ID); if (s) s.remove(); } catch (_) {}
  };

  /* =========================
   * USER GUARD
   * ======================= */
  const installUserGuard = () => {
    const isPuck = (t) => { try { return !!(t && t.closest && t.closest("#"+UI.PANEL_ID)); } catch (_) { return false; } };

    const onDown = (e) => { if (!e?.isTrusted) return; if (isPuck(e.target)) return; userDown=true; markUserBusy(CFG.USER_GRACE_ON_DOWN_MS); };
    const onUp   = (e) => { if (!e?.isTrusted) return; if (isPuck(e.target)) return; userDown=false; markUserBusy(CFG.USER_GRACE_AFTER_UP_MS); };
    const onWheel= (e) => { if (!e?.isTrusted) return; if (isPuck(e.target)) return; markUserBusy(CFG.USER_GRACE_ON_WHEEL_MS); };
    const onKey  = (e) => { if (!e?.isTrusted) return; markUserBusy(CFG.USER_GRACE_ON_KEY_MS); };
    const onBlur = () => { try { userDown = false; markUserBusy(120); } catch (_) {} };

    const wheelOpt = { capture:true, passive:true };
    const touchOpt = { capture:true, passive:true };

    addEventListener("pointerdown", onDown, true);
    addEventListener("pointerup", onUp, true);
    addEventListener("mousedown", onDown, true);
    addEventListener("mouseup", onUp, true);

    addEventListener("touchstart", onDown, touchOpt);
    addEventListener("touchend", onUp, touchOpt);
    addEventListener("touchcancel", onUp, touchOpt);

    addEventListener("wheel", onWheel, wheelOpt);
    addEventListener("keydown", onKey, true);
    addEventListener("blur", onBlur, true);

    installUserGuard._rm = () => {
      try { removeEventListener("pointerdown", onDown, true); } catch (_) {}
      try { removeEventListener("pointerup", onUp, true); } catch (_) {}
      try { removeEventListener("mousedown", onDown, true); } catch (_) {}
      try { removeEventListener("mouseup", onUp, true); } catch (_) {}

      try { removeEventListener("touchstart", onDown, touchOpt); } catch (_) {}
      try { removeEventListener("touchend", onUp, touchOpt); } catch (_) {}
      try { removeEventListener("touchcancel", onUp, touchOpt); } catch (_) {}

      try { removeEventListener("wheel", onWheel, wheelOpt); } catch (_) {}
      try { removeEventListener("keydown", onKey, true); } catch (_) {}
      try { removeEventListener("blur", onBlur, true); } catch (_) {}
    };
  };

  const uninstallUserGuard = () => { try { installUserGuard._rm && installUserGuard._rm(); } catch (_) {} };

  /* =========================
   * NAV HOOKS + SHADOW PATCH
   * ======================= */
  const installNavHooks = () => {
    history.pushState = function () { const ret = ORIG.pushState.apply(this, arguments); if (on) { scheduleBurst(700); cbKick(); } return ret; };
    history.replaceState = function () { const ret = ORIG.replaceState.apply(this, arguments); if (on) { scheduleBurst(700); cbKick(); } return ret; };

    onPop = () => { if (on) { scheduleBurst(700); cbKick(); } };
    addEventListener("popstate", onPop, true);

    onFocus = () => { if (on) { scheduleBurst(520); cbKick(); } };
    addEventListener("focus", onFocus, false);

    onVis = () => { if (on && document.visibilityState === "visible") { scheduleBurst(700); cbKick(); } };
    document.addEventListener("visibilitychange", onVis, false);
  };

  const uninstallNavHooks = () => {
    try { history.pushState = ORIG.pushState; } catch (_) {}
    try { history.replaceState = ORIG.replaceState; } catch (_) {}
    try { if (onPop) removeEventListener("popstate", onPop, true); } catch (_) {}
    try { if (onFocus) removeEventListener("focus", onFocus, false); } catch (_) {}
    try { if (onVis) document.removeEventListener("visibilitychange", onVis, false); } catch (_) {}
    onPop = onFocus = onVis = null;
  };

  const installShadowPatch = () => {
    try {
      Element.prototype.attachShadow = function () {
        const sr = ORIG.attachShadow.apply(this, arguments);
        try { if (on) wireRoot(sr); } catch (_) {}
        try { if (on) cbKick(); } catch (_) {}
        return sr;
      };
    } catch (_) {}
  };

  const uninstallShadowPatch = () => { try { Element.prototype.attachShadow = ORIG.attachShadow; } catch (_) {} };

  /* =========================
   * START/STOP
   * ======================= */
  const startWatchers = () => {
    wireRoot(document.documentElement || document);
    try { document.querySelectorAll("iframe").forEach(wireFrame); } catch (_) {}
    bindShortcut(window);

    try { document.querySelectorAll(CFG.WRAP_SEL).forEach((w) => registerWrap(w)); } catch (_) {}
    if (!pollTimer) pollTimer = setInterval(() => { scanAndRegister(); }, CFG.FALLBACK_POLL_MS);

    cbWire();
    scheduleBurst(900);
  };

  const stopWatchers = () => {
    while (rootMOs.length) { const mo = rootMOs.pop(); try { mo.disconnect(); } catch (_) {} }

    try { if (hotTimer) clearTimeout(hotTimer); } catch (_) {}
    try { if (rafId) cancelAnimationFrame(rafId); } catch (_) {}
    hotTimer = 0; rafId = 0; burstUntil = 0; burstHotUntil = 0;

    try { if (pollTimer) clearInterval(pollTimer); } catch (_) {}
    pollTimer = 0;

    pendingBurst = false;
    try { if (wakeTimer) clearTimeout(wakeTimer); } catch (_) {}
    wakeTimer = 0;

    cbUnwire();
  };

  const toggle = () => {
    GEN++;
    on = !on;
    updateUI();
    if (on) startWatchers();
    else stopWatchers();
  };

  function kill() {
    try {
      on = false;
      GEN++;

      stopWatchers();
      unbindShortcuts();
      uninstallNavHooks();
      uninstallShadowPatch();
      uninstallUserGuard();

      try { const d = document.getElementById(UI.PANEL_ID); if (d) d.remove(); } catch (_) {}
      try { const s = document.getElementById(UI.STYLE_ID); if (s) s.remove(); } catch (_) {}
      try { const cs = document.getElementById(UI.CB_STYLE_ID); if (cs) cs.remove(); } catch (_) {}

      try { delete window._s1panelKill; } catch (_) { window._s1panelKill = undefined; }
    } catch (_) {}
  }

  window._s1panelKill = kill;

  lastUserAt = now();
  buildUI();
  installUserGuard();
  installNavHooks();
  installShadowPatch();
  startWatchers();
})();